<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      《操作系统真象还原》：第八章 内存管理系统 | Songqian Li&#39;s Blog
    
  </title>
  <meta name="author" content="Songqian Li">
  <meta name="keywords" content="" />
  <meta name="description" content="去历史上留点故事" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">
<!--  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900">-->
  <link rel="stylesheet" href="https://fonts.font.im/css?family=Playfair+Display:400,700,900">
  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: false
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'L0W62cCkHAgT0VsIX6WztMhp-gzGzoHsz',
	  appKey: 'n1lX9eWfotXltQ6Cab3ngGfk',
	  serverURLs: 'https://l0w62cck.lc-cn-n1-shared.com' || ' '
    }
  </script>
  <!-- site analysis -->
  

	<!-- site-analysis -->
	
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "//hm.baidu.com/hm.js?b702b9b0aa72233c214dcbade17a5a27";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	
	
	
	
 
    <meta name="referrer" content="no-referrer"/>
<meta name="generator" content="Hexo 6.3.0"></head>
	<body>
		<!-- Preloader -->


<!-- header -->
<header class="fixbackground">
		<div class="header-wrapper">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	<div class="mask">
	<div class="banner-frame border-image" style="border-image-source: url('/img/mask.png');"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-12">
					<div class="align">
						<h1 class="h1 light">Songqian Li&#39;s Blog</h1>
						<div class="empty-space col-xs-b15"></div>
						<div class="sa light large">去历史上留点故事</div>
						<div class="empty-space col-xs-b30"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- motto -->
		<div class="h-body">	
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「《操作系统真象还原》：第八章 内存管理系统」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<!--<span class="logo"> 
			<img src="/img/logo.png">
		</span> -->
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="//github.com/lisongqian" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2023/01/20/yuque/dch1fprebtaxtqq8/" itemprop="url">
		《操作系统真象还原》：第八章 内存管理系统
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2023/01/20/yuque/dch1fprebtaxtqq8/" itemprop="url">
		<time datetime="2023-01-20T12:54:57.000Z" itemprop="dateUpdated">
	  		2024-01-08
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/OS/" class=" ">
			OS
		</a>
	
		<a href="/tags/Reading/" class=" ">
			Reading
		</a>
	
		
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<h3 id="8-1-makefile-简介"><a href="#8-1-makefile-简介" class="headerlink" title="8.1 makefile 简介"></a>8.1 makefile 简介</h3><blockquote>
<p>这部分可参考阮一峰的讲解：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/02/make.html">https://www.ruanyifeng.com/blog/2015/02/make.html</a></p>
</blockquote>
<h4 id="8-1-1-makefile-是什么"><a href="#8-1-1-makefile-是什么" class="headerlink" title="8.1.1 makefile 是什么"></a>8.1.1 makefile 是什么</h4><p>makefile 是 Linux 下编译大型程序的工具，是 make 程序的搭档，两者的主要功能就是发现某个文件更新后，只编译该文件和受该文件影响的相关文件，从而提高了编译效率。<br>make 和 makefile 并不是用来编译程序的，它只负责找出哪些文件有变化， 并 且根据依赖关系找出受影响的文件，然后执行事先在 makefile 中定义好的命令规则。因为 make 就是在 shell 下执行的，所以在 makefile 中，位于命令规则里的那些命令， 都是 shell 命令。</p>
<h4 id="8-1-2-makefile-基本语法"><a href="#8-1-2-makefile-基本语法" class="headerlink" title="8.1.2 makefile 基本语法"></a>8.1.2 makefile 基本语法</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标文件:依赖文件</span></span><br><span class="line">[Tab]命令</span><br></pre></td></tr></table></figure>

<p>makefile 基本语法包括三部分，这三部分加在一起称为一组规则：</p>
<ol>
<li>目标文件是指此规则中想要生成的文件，可以是.o 结尾的目标文件，也可以是可执行文件或伪目标。</li>
<li>依赖文件是指要生成此规则中的目标文件，需要哪些文件。通常依赖文件不是 1 个，所以此处是个依赖文件的列表。</li>
<li>命令是指此规则中要执行的动作，这些动作是指各种 shell 命令。命令可以有多个，但一个命令要单独占一行，行首必须以 Tab 开头。<blockquote>
<p>Linux 中文件分为属性和数据两部分，每个文件有三种时间：</p>
<ol>
<li>atime，即 access time，表示访问文件数据部分时间，每次读取文件数据部分时就会更新 atime。</li>
<li>ctime，即 change time，表示文件属性或数据的改变时间。</li>
<li>mtime，即 modify time，表示文件数据部分的修改时间。</li>
</ol>
</blockquote>
</li>
</ol>
<p>make 程序分别获取依赖文件和目标文件的 mtime，对比依赖文件是否比目标文件的 mtime 新，从而得知是否要执行规则中的命令。<br>举例说明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">file1:file2</span></span><br><span class="line">	@echo <span class="string">&quot;makefile test ok&quot;</span></span><br></pre></td></tr></table></figure>

<p>文件的含义是：若 file2 比 file1 新，则输出“makefile test ok”。“@”是关闭打印命令本身。<br>makefile 的文件名不固定，可以在执行 make 时用-f 参数执行。如果未用-f 指定，默认 make 会按照<code>GNUmakefile</code>、<code>makefile</code>、<code>Makefile</code>的顺序找 makefile 文件。</p>
<h4 id="8-1-3-跳到目标处执行"><a href="#8-1-3-跳到目标处执行" class="headerlink" title="8.1.3 跳到目标处执行"></a>8.1.3 跳到目标处执行</h4><p>如果 makefile 有多个目标，可以用<code>make target_name</code>来执行，如果不指定目标，则默认执行第一个目标。</p>
<h4 id="8-1-4-伪目标"><a href="#8-1-4-伪目标" class="headerlink" title="8.1.4 伪目标"></a>8.1.4 伪目标</h4><blockquote>
<p>当规则中不存在依赖文件时，这个目标文件名就是伪目标。</p>
</blockquote>
<p>可以使用关键字<code>.PHONY</code>来明确声明伪目标，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm ./build/*.o</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1672019698574-6bfbf8f7-c920-4223-9e82-b6df183275e8.png#averageHue=%23e6e6e6&clientId=u4a9676ba-c70c-4&from=paste&height=152&id=u606f0dbb&originHeight=152&originWidth=858&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=79990&status=done&style=none&taskId=ua60af1c8-5fa1-4658-842d-da8fee758b6&title=&width=858" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1672019709491-78ec4b8b-3135-4940-85b6-ceeb7ba01767.png#averageHue=%23dbdbdb&clientId=u4a9676ba-c70c-4&from=paste&height=157&id=u9eea0320&originHeight=157&originWidth=860&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=113911&status=done&style=none&taskId=ua8821d10-3b1a-4936-b565-1783f0e3252&title=&width=860" alt="image.png"></p>
<h4 id="8-1-5-make-递归式推导目标"><a href="#8-1-5-make-递归式推导目标" class="headerlink" title="8.1.5 make: 递归式推导目标"></a>8.1.5 make: 递归式推导目标</h4><p>举例说明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test1.o:test1.c</span></span><br><span class="line">	gcc -c -o test1.o test1.c</span><br><span class="line"><span class="section">test2.o:test2.c</span></span><br><span class="line">	gcc -c -o test2.o test2.c</span><br><span class="line"><span class="section">test.bin:test1.o test2.o</span></span><br><span class="line">	gcc -o test.bin test1.o test2.o</span><br><span class="line"><span class="section">all:test.bin</span></span><br><span class="line">	@echo <span class="string">&quot;compile done&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行<code>make all</code>时，make 会递归执行 all，依赖文件不存在或不是最新就去找该依赖文件名命名的规则执行，执行完后再找下一个依赖文件。故最终执行顺序是：test1.o、test2.o、test.bin、all。</p>
<h4 id="8-1-6-自定义变量与系统变量"><a href="#8-1-6-自定义变量与系统变量" class="headerlink" title="8.1.6 自定义变量与系统变量"></a>8.1.6 自定义变量与系统变量</h4><p>自定义变量仅支持字符串类型，即使是数字也被当做字符串来处理，变量引用格式：<code>$(变量名)</code>，举例说明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test0.o:test0.c</span></span><br><span class="line">	gcc -c -o test0.o test0.c</span><br><span class="line"><span class="section">test1.o:test1.c</span></span><br><span class="line">	gcc -c -o test1.o test1.c</span><br><span class="line">objfiles = test0.c test1.c</span><br><span class="line"><span class="section">all:<span class="variable">$(objfiles)</span></span></span><br><span class="line">	@echo <span class="string">&quot;compile done&quot;</span></span><br></pre></td></tr></table></figure>

<p>还有一些系统级的变量：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1672020515940-081d0f9f-8221-466f-bff5-77d2589d9271.png#averageHue=%23e6e6e6&clientId=u4a9676ba-c70c-4&from=paste&height=726&id=ud44c1c88&originHeight=726&originWidth=860&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=368655&status=done&style=none&taskId=u191ba738-7a40-4ea3-b7a3-54272fd4bd5&title=&width=860" alt="image.png"><br>在命令相关的系统变量是有默认值的，一般参数相关的变量没有默认值。</p>
<h4 id="8-1-7-隐含规则"><a href="#8-1-7-隐含规则" class="headerlink" title="8.1.7 隐含规则"></a>8.1.7 隐含规则</h4><ol>
<li>行尾添加反斜杠字符’&#39;，下一行内容会被认为是同一行；</li>
<li>可以用’#’进行单行注释；</li>
<li>语言程序的隐含规则：<ol>
<li>C 程序：”x.o”的生成依赖于”x.c”，生成 x.o 的命令为：<code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li>
<li>C++程序：”x.o”的生成依赖于”x.cc”，生成 x.o 的命令为：<code>$(CXX) -c $(CPPFGLAGS) $(CFLAGS)</code></li>
<li>Pascal 程序：”x.o”的生成依赖于”x.p”，生成 x.o 的命令为：<code>$(PC) -c $(PFLAGS)</code></li>
</ol>
</li>
</ol>
<h4 id="8-1-8-自动化变量"><a href="#8-1-8-自动化变量" class="headerlink" title="8.1.8 自动化变量"></a>8.1.8 自动化变量</h4><ol>
<li><code>$@</code>，表示规则中的<strong>目标文件</strong>名集合。</li>
<li><code>$&lt;</code>，表示规则中依赖文件中的第 1 个文件。</li>
<li><code>$^</code>，表示规则中所有<strong>依赖文件</strong>的集合。</li>
<li><code>$?</code>，表示规则中所有比目标文件 mtime 更新的依赖文件集合。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test1.o:test1.c</span></span><br><span class="line">	gcc -c -o test1.o test1.c</span><br><span class="line"><span class="section">test2.o:test2.c</span></span><br><span class="line">	gcc -c -o test2.o test2.c</span><br><span class="line"><span class="section">test.bin:test1.o test2.o</span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">all:test.bin</span></span><br><span class="line">	@echo <span class="string">&quot;compile done&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-1-9-模式规则"><a href="#8-1-9-模式规则" class="headerlink" title="8.1.9 模式规则"></a>8.1.9 模式规则</h4><p>%用来匹配任意多个非空字符，如果是匹配文件，默认在当前路径下匹配。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">objfiles = test1.o test2.o</span><br><span class="line"><span class="section">test.bin:<span class="variable">$(objfiles)</span></span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">all:test.bin</span></span><br><span class="line">	@echo <span class="string">&quot;compile done&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-实现-assert-断言"><a href="#8-2-实现-assert-断言" class="headerlink" title="8.2 实现 assert 断言"></a>8.2 实现 assert 断言</h3><h4 id="8-2-1-实现开、关中断的函数"><a href="#8-2-1-实现开、关中断的函数" class="headerlink" title="8.2.1 实现开、关中断的函数"></a>8.2.1 实现开、关中断的函数</h4><p>在相应文件添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF   0x00000200       <span class="comment">// eflags寄存器中的if位为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_EFLAGS(EFLAG_VAR) asm volatile(<span class="string">&quot;pushfl; popl %0&quot;</span> : <span class="string">&quot;=g&quot;</span> (EFLAG_VAR))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 开中断</span></span><br><span class="line"><span class="comment"> * @return 中断前状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_enable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INTR_ON == intr_get_status()) &#123;</span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;sti&quot;</span>);	 <span class="comment">// 开中断,sti指令将IF位置1</span></span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 关中断</span></span><br><span class="line"><span class="comment"> * @return 中断前的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_disable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INTR_ON == intr_get_status()) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span> : : : <span class="string">&quot;memory&quot;</span>)</span>; <span class="comment">// 关中断,cli指令将IF位置0</span></span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将中断状态设置为status</span></span><br><span class="line"><span class="comment"> * @param status 中断状态</span></span><br><span class="line"><span class="comment"> * @return 中断前状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_set_status</span><span class="params">(<span class="keyword">enum</span> intr_status status)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status &amp; INTR_ON ? intr_enable() : intr_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 获取当前中断状态</span></span><br><span class="line"><span class="comment"> * @return 当前中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_get_status</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags = <span class="number">0</span>;</span><br><span class="line">    GET_EFLAGS(eflags);</span><br><span class="line">    <span class="keyword">return</span> (EFLAGS_IF &amp; eflags) ? INTR_ON : INTR_OFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义中断的两种状态:</span></span><br><span class="line"><span class="comment"> * INTR_OFF值为0,表示关中断,</span></span><br><span class="line"><span class="comment"> * INTR_ON值为1,表示开中断 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> &#123;</span>		 <span class="comment">// 中断状态</span></span><br><span class="line">    INTR_OFF,			 <span class="comment">// 中断关闭</span></span><br><span class="line">    INTR_ON		         <span class="comment">// 中断打开</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_get_status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_set_status</span> <span class="params">(<span class="keyword">enum</span> intr_status)</span>;</span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_enable</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_disable</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-实现-ASSERT"><a href="#8-2-2-实现-ASSERT" class="headerlink" title="8.2.2 实现 ASSERT"></a>8.2.2 实现 ASSERT</h4><p>ASSERT 的原理是判断传给 ASSERT 的表达式是否成立，若表达式成立则什么都不做，否则打印出错信息并停止执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_DEBUG_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic_spin</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *condition)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************  __VA_ARGS__  *******************************</span></span><br><span class="line"><span class="comment"> * __VA_ARGS__ 是预处理器所支持的专用标识符。</span></span><br><span class="line"><span class="comment"> * 代表所有与省略号相对应的参数.</span></span><br><span class="line"><span class="comment"> * &quot;...&quot;表示定义的宏其参数可变.*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PANIC(...) panic_spin (__FILE__, __LINE__, __func__, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">/***********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(CONDITION) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(CONDITION)                          \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (CONDITION) &#123;&#125; <span class="keyword">else</span> &#123;                     \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* 符号#让编译器将宏的参数转化为字符串字面量 */</span>    \</span></span><br><span class="line"><span class="meta">        PANIC(#CONDITION);                         \</span></span><br><span class="line"><span class="meta">      &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//NDEBUG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//__KERNEL_DEBUG_H</span></span></span><br></pre></td></tr></table></figure>

<p>第 10 行中的宏：</p>
<ol>
<li><code>__FILE__</code>表示被编译的文件名；</li>
<li><code>__LINE__</code>表示编译文件中的行号；</li>
<li><code>__func__</code>表示被编译的函数名；</li>
<li><code>__VA_ARGS__</code>是可变参数<code>...</code>的表示符，它代表所有与省略号相对应的参数。</li>
</ol>
<p>第 19 行的<code>#CONDITION</code>，其中字符<code>#</code>的作用是让预处理器把 CONDITION 转换成字符串常量，比如 CONDITION 为<code>var!=0</code>，#CONDITION 则为字符串<code>&quot;var!=0&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 打印文件名,行号,函数名,条件并使程序悬停</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param line 行号</span></span><br><span class="line"><span class="comment"> * @param func 函数名</span></span><br><span class="line"><span class="comment"> * @param condition 条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic_spin</span><span class="params">(<span class="type">char</span>* filename,</span></span><br><span class="line"><span class="params">	            <span class="type">int</span> line,</span></span><br><span class="line"><span class="params">		        <span class="type">const</span> <span class="type">char</span>* func,</span></span><br><span class="line"><span class="params">		        <span class="type">const</span> <span class="type">char</span>* condition)</span></span><br><span class="line">&#123;</span><br><span class="line">    intr_disable();	<span class="comment">// 因为有时候会单独调用panic_spin,所以在此处关中断。</span></span><br><span class="line">    put_str(<span class="string">&quot;\n\n\n!!!!! error !!!!!\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;filename:&quot;</span>);put_str(filename);put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;line:0x&quot;</span>);put_int(line);put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;function:&quot;</span>);put_str((<span class="type">char</span>*)func);put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;condition:&quot;</span>);put_str((<span class="type">char</span>*)condition);put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 main.c 中测试一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;I am kernel\n&quot;</span>);</span><br><span class="line">    init_all();</span><br><span class="line">    ASSERT(<span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上次把中断打开是为了演示中断，现在暂时给关了，等时机成熟了再打开。</p>
</blockquote>
<h4 id="8-2-3-通过-makefile-来编译"><a href="#8-2-3-通过-makefile-来编译" class="headerlink" title="8.2.3 通过 makefile 来编译"></a>8.2.3 通过 makefile 来编译</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR = ./build</span><br><span class="line">DISK_IMG = hd60M.img</span><br><span class="line">ENTRY_POINT = 0xc0001500</span><br><span class="line">AS = nasm</span><br><span class="line">CC = gcc</span><br><span class="line">LD = ld</span><br><span class="line">LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/</span><br><span class="line">ASFLAGS = -f elf</span><br><span class="line">ASBINLIB = -I boot/<span class="keyword">include</span>/</span><br><span class="line">CFLAGS = -m32 -Wall <span class="variable">$(LIB)</span> -c -fno-builtin -W -Wstrict-prototypes \</span><br><span class="line">-Wmissing-prototypes -fno-stack-protector</span><br><span class="line">LDFLAGS = -m elf_i386 -Ttext <span class="variable">$(ENTRY_POINT)</span> -e main -Map <span class="variable">$(BUILD_DIR)</span>/kernel.map</span><br><span class="line">OBJS = <span class="variable">$(BUILD_DIR)</span>/main.o <span class="variable">$(BUILD_DIR)</span>/init.o <span class="variable">$(BUILD_DIR)</span>/interrupt.o \</span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/timer.o <span class="variable">$(BUILD_DIR)</span>/kernel.o <span class="variable">$(BUILD_DIR)</span>/print.o \</span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/debug.o</span><br><span class="line"></span><br><span class="line"><span class="comment">##############     MBR代码编译     ###############</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/mbr.bin: boot/mbr.S</span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASBINLIB)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############     bootloader代码编译     ###############</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/loader.bin: boot/loader.S</span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASBINLIB)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############     c代码编译     ###############</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/main.o: kernel/main.c lib/kernel/print.h \</span><br><span class="line">lib/stdint.h kernel/init.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \</span><br><span class="line">lib/stdint.h kernel/interrupt.h device/timer.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/interrupt.o: kernel/interrupt.c kernel/interrupt.h \</span><br><span class="line">lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/timer.o: device/timer.c device/timer.h lib/stdint.h\</span><br><span class="line">lib/kernel/io.h lib/kernel/print.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/debug.o: kernel/debug.c kernel/debug.h \</span><br><span class="line">lib/kernel/print.h lib/stdint.h kernel/interrupt.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############    汇编代码编译    ###############</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/kernel.o: kernel/kernel.S</span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/print.o: lib/kernel/print.S</span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############    链接所有目标文件    #############</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/kernel.bin: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY : mk_dir mk_img mbr2hd loader2hd kernel2hd clean all</span><br><span class="line"></span><br><span class="line"><span class="section">mk_dir:</span></span><br><span class="line">if [ ! -d <span class="variable">$(BUILD_DIR)</span> ];then mkdir <span class="variable">$(BUILD_DIR)</span>;fi</span><br><span class="line"></span><br><span class="line"><span class="section">mk_img:</span></span><br><span class="line">if [ ! -e <span class="variable">$(DISK_IMG)</span> ];then /usr/bin/bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q <span class="variable">$(DISK_IMG)</span>;fi</span><br><span class="line"></span><br><span class="line"><span class="section">mbr2hd:</span></span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASBINLIB)</span> -o <span class="variable">$(BUILD_DIR)</span>/mbr.bin boot/mbr.S</span><br><span class="line">dd if=<span class="variable">$(BUILD_DIR)</span>/mbr.bin of=<span class="variable">$(DISK_IMG)</span> bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="section">loader2hd:</span></span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASBINLIB)</span> -o <span class="variable">$(BUILD_DIR)</span>/loader.bin  boot/loader.S</span><br><span class="line">dd if=<span class="variable">$(BUILD_DIR)</span>/loader.bin of=<span class="variable">$(DISK_IMG)</span> bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line"><span class="section">kernel2hd:</span></span><br><span class="line">dd if=<span class="variable">$(BUILD_DIR)</span>/kernel.bin \</span><br><span class="line">of=<span class="variable">$(DISK_IMG)</span> \</span><br><span class="line">bs=512 count=200 seek=9 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">cd <span class="variable">$(BUILD_DIR)</span> &amp;&amp; rm -f ./*</span><br><span class="line"></span><br><span class="line"><span class="section">build: <span class="variable">$(BUILD_DIR)</span>/kernel.bin</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: mk_dir build kernel2hd</span></span><br></pre></td></tr></table></figure>

<p>执行<code>make all</code>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1672040367404-9cf7ee5c-e6c1-425b-a408-6b04ceb46ae4.png#averageHue=%231d1d1c&clientId=u4a9676ba-c70c-4&from=paste&height=365&id=u69b014b3&originHeight=486&originWidth=722&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16634&status=done&style=none&taskId=u867b5941-ee66-4119-bbcb-47c34ac138e&title=&width=542" alt="image.png"></p>
<h3 id="8-3-实现字符串操作函数"><a href="#8-3-实现字符串操作函数" class="headerlink" title="8.3 实现字符串操作函数"></a>8.3 实现字符串操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIB_STRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIB_STRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">uint8_t</span> value, <span class="type">uint32_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">const</span> <span class="type">void</span>* src_, <span class="type">uint32_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">uint32_t</span> size)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst_, <span class="type">const</span> <span class="type">char</span>* src_)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span>;</span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">uint8_t</span> ch)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">uint8_t</span> ch)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dst_, <span class="type">const</span> <span class="type">char</span>* src_)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">strchrs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">uint8_t</span> ch)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 内存赋值函数，将dst_起始的size个字节置为value</span></span><br><span class="line"><span class="comment"> * @param dst_ 目的地址</span></span><br><span class="line"><span class="comment"> * @param value 数值,一字节大小</span></span><br><span class="line"><span class="comment"> * @param size 大小,单位字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">uint8_t</span> value, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = (<span class="type">uint8_t</span>*) dst_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">        *dst++ = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 内存拷贝函数，将src_起始的size个字节复制到dst_</span></span><br><span class="line"><span class="comment"> * @param dst_ 目的地址</span></span><br><span class="line"><span class="comment"> * @param src_ 源地址</span></span><br><span class="line"><span class="comment"> * @param size 大小，单位字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">const</span> <span class="type">void</span>* src_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span> &amp;&amp; src_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = dst_;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* src = src_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">        *dst++ = *src++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 内存比较函数，连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1</span></span><br><span class="line"><span class="comment"> * @param a_ 内存块a</span></span><br><span class="line"><span class="comment"> * @param b_ 内存块b</span></span><br><span class="line"><span class="comment"> * @param size 大小</span></span><br><span class="line"><span class="comment"> * @return a&gt;b return 1; a==b return 0; a&lt;b return -1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* a = a_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* b = b_;</span><br><span class="line">    ASSERT(a != <span class="literal">NULL</span> || b != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*a != *b) &#123;</span><br><span class="line">            <span class="keyword">return</span> *a &gt; *b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符串拷贝函数，将字符串从src_复制到dst_</span></span><br><span class="line"><span class="comment"> * @param dst_ 目的地址</span></span><br><span class="line"><span class="comment"> * @param src_ 源地址</span></span><br><span class="line"><span class="comment"> * @return 目的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst_, <span class="type">const</span> <span class="type">char</span>* src_)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span> &amp;&amp; src_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* r = dst_;               <span class="comment">// 用来返回目的字符串起始地址</span></span><br><span class="line">    <span class="keyword">while</span> ((*dst_++ = *src_++));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符串长度函数</span></span><br><span class="line"><span class="comment"> * @param str 字符串</span></span><br><span class="line"><span class="comment"> * @return 字符串长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = str;</span><br><span class="line">    <span class="keyword">while</span> (*p++);</span><br><span class="line">    <span class="keyword">return</span> (p - str - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符串比较函数</span></span><br><span class="line"><span class="comment"> * @param a 字符串a</span></span><br><span class="line"><span class="comment"> * @param b 字符串b</span></span><br><span class="line"><span class="comment"> * @return a&gt;b return 1; a==b return 0; 否则 return -1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    ASSERT(a != <span class="literal">NULL</span> &amp;&amp; b != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*a != <span class="number">0</span> &amp;&amp; *a == *b) &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式&quot;*a &gt; *b&quot;中,</span></span><br><span class="line"><span class="comment">// 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b</span></span><br><span class="line">    <span class="keyword">return</span> *a &lt; *b ? <span class="number">-1</span> : *a &gt; *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符查找函数，从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址)</span></span><br><span class="line"><span class="comment"> * @param str 待查找的字符串</span></span><br><span class="line"><span class="comment"> * @param ch 要查找的字符</span></span><br><span class="line"><span class="comment"> * @return ch首次出现的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">uint8_t</span> ch)</span> &#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>*) str;  <span class="comment">// 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.</span></span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符反向查找函数，从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址)</span></span><br><span class="line"><span class="comment"> * @param str 待查找的字符串</span></span><br><span class="line"><span class="comment"> * @param ch 要查找的字符</span></span><br><span class="line"><span class="comment"> * @return ch最后出现的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">uint8_t</span> ch)</span> &#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* last_char = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch) &#123;</span><br><span class="line">            last_char = str;</span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*) last_char;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符串拼接函数，将字符串src_拼接到dst_后,将回拼接的串地址</span></span><br><span class="line"><span class="comment"> * @param dst_ 目的字符串地址</span></span><br><span class="line"><span class="comment"> * @param src_ 源字符串地址</span></span><br><span class="line"><span class="comment"> * @return 目的字符串地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dst_, <span class="type">const</span> <span class="type">char</span>* src_)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span> &amp;&amp; src_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* str = dst_;</span><br><span class="line">    <span class="keyword">while</span> (*str++);</span><br><span class="line">    --str;      <span class="comment">// 别看错了，--str是独立的一句，并不是while的循环体</span></span><br><span class="line">    <span class="keyword">while</span> ((*str++ = *src_++));     <span class="comment">// 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.</span></span><br><span class="line">    <span class="keyword">return</span> dst_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 字符查找函数，在字符串str中查找指定字符ch出现的次数</span></span><br><span class="line"><span class="comment"> * @param str 待查找的字符串</span></span><br><span class="line"><span class="comment"> * @param ch 要查找的字符</span></span><br><span class="line"><span class="comment"> * @return ch出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">strchrs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">uint8_t</span> ch)</span> &#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint32_t</span> ch_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = str;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == ch) &#123;</span><br><span class="line">            ch_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-位图-bitmap-及其函数实现"><a href="#8-4-位图-bitmap-及其函数实现" class="headerlink" title="8.4 位图 bitmap 及其函数实现"></a>8.4 位图 bitmap 及其函数实现</h3><h4 id="8-4-1-位图简介"><a href="#8-4-1-位图简介" class="headerlink" title="8.4.1 位图简介"></a>8.4.1 位图简介</h4><p>位图就是用字节中的 1 位来映射其他单位大小的资源，按位与资源之间是一对一的对应关系。位图相当于一组资源的映射，故位图主要用于管理容量较大的资源。</p>
<h4 id="8-4-2-位图的定义与实现"><a href="#8-4-2-位图的定义与实现" class="headerlink" title="8.4.2 位图的定义与实现"></a>8.4.2 位图的定义与实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIB_KERNEL_BITMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIB_KERNEL_BITMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> btmp_bytes_len;</span><br><span class="line"><span class="comment">/* 在遍历位图时,整体上以字节为单位,细节上是以位为单位,所以此处位图的指针必须是单字节 */</span></span><br><span class="line">    <span class="type">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 将位图btmp初始化</span></span><br><span class="line"><span class="comment"> * @param btmp 位图指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 判断bit_idx位是否为1,若为1则返回1，否则返回0</span></span><br><span class="line"><span class="comment"> * @param btmp 位图指针</span></span><br><span class="line"><span class="comment"> * @param bit_idx 位索引</span></span><br><span class="line"><span class="comment"> * @return bit_idx==1?true:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整用于索引数组下标</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余用于索引数组内的位</span></span><br><span class="line">    <span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1</span></span><br><span class="line"><span class="comment"> * @param btmp 位图指针</span></span><br><span class="line"><span class="comment"> * @param cnt 位的个数</span></span><br><span class="line"><span class="comment"> * @return 起始位下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>;	 <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line"><span class="comment">/* 先逐字节比较,蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> (( <span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len)) &#123;</span><br><span class="line"><span class="comment">/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len) &#123;  <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位，</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对,返回空闲位的索引。*/</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte]) &#123;</span><br><span class="line">        idx_bit++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;    <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);   <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>;	      <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;	      <span class="comment">// 先将其置为-1,若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit))) &#123;	 <span class="comment">// 若next_bit为0</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt) &#123;	    <span class="comment">// 若找到连续的cnt个空位</span></span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 将位图btmp的bit_idx位设置为0或1</span></span><br><span class="line"><span class="comment"> * @param btmp 位图指针</span></span><br><span class="line"><span class="comment"> * @param bit_idx 位索引</span></span><br><span class="line"><span class="comment"> * @param value 数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span> &#123;</span><br><span class="line">    ASSERT((value == <span class="number">0</span>) || (value == <span class="number">1</span>));</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整用于索引数组下标</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余用于索引数组内的位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一般都会用个0x1这样的数对字节中的位操作,</span></span><br><span class="line"><span class="comment"> * 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/</span></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;		  <span class="comment">// 如果value为1</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;		      <span class="comment">// 若为0</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>置 1 用或操作，置 0 用与操作。</p>
<h3 id="8-5-内存管理系统"><a href="#8-5-内存管理系统" class="headerlink" title="8.5 内存管理系统"></a>8.5 内存管理系统</h3><p>本节将实现内存管理系统，并将实现 malloc 和 free 函数。</p>
<h4 id="8-5-1-内存池规划"><a href="#8-5-1-内存池规划" class="headerlink" title="8.5.1 内存池规划"></a>8.5.1 内存池规划</h4><p>内存地址池的概念是将可用的内存地址集中放到一个“池子”中，需要的时候直接从里面取出， 完后再放回去。由于在分页机制下有了虚拟地址和物理地址，为了有效地管理它们，我们需要创建虚拟内存地址池和物理内存地址池。<br>物理内存地址池分为两部分：</p>
<ol>
<li>内核物理内存池，只用来运行内核</li>
<li>用户物理内存池，只用来运行用户进程</li>
</ol>
<p>为了方便实现，这里把这两个内存池的大小设为一致，各占一半的物理内存。<br>对于虚拟内存地址池：</p>
<ul>
<li>内核进程从内核虚拟地址池中分配地址，再从内核物理内存池中分配物理内存，然后在内核自己的页表中将两个地址建立好映射关系。</li>
<li>用户进程从用户进程虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池中分配空闲的物理内存，然后在该用户进程自己的页表将这两种地址建立好映射关系。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1249968/1673509920183-d8f8bc1f-aa21-4d01-894f-197bdedfca6a.png#averageHue=%23dbdbdb&clientId=ua2d1b002-da8b-4&from=paste&height=313&id=ue5a74a3e&originHeight=313&originWidth=354&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=98701&status=done&style=none&taskId=ub3a0ad6d-23f5-4b3d-a2f5-9707fb6752b&title=&width=354" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL_MEMORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_MEMORY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bitmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于虚拟地址管理 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span> <span class="comment">// 虚拟地址用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;       <span class="comment">// 虚拟地址起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>virtual<em>addr 是虚拟地址池，用于虚拟地址管理。为了演示分页机制是如何将这两种独立不相关的地址关联到一起的，特意加了该结构体用于管理虚拟地址。<br>struct virtual</em> addr 包含两个成员，一个是 vaddr_bitmap，用来以页位单位管理虚拟地址的分配情况。虽然多个进程可以有相同的虚拟地址，但其实是因为这些虚拟地址对应的物理地址是不同的，在同一进程内的虚拟地址必然是唯一的，这是由链接器为其分配，由链接器负责虚拟地址的唯一性。另一个是 vaddr_start ，将来在分配虚拟地址时将以这个地址为起始分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096            <span class="comment">// 页大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="comment">/*************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START 0xc0100000 <span class="comment">// 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池结构,生成两个实例用于管理内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span>     <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start;     <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;         <span class="comment">// 本内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>     <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 初始化内存池</span></span><br><span class="line"><span class="comment"> * @param all_mem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_pool_init</span><span class="params">(<span class="type">uint32_t</span> all_mem)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;   mem_pool_init start\n&quot;</span>);</span><br><span class="line">    <span class="type">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;      <span class="comment">// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+</span></span><br><span class="line">    <span class="comment">// 第769~1022个页目录项共指向254个页表,共256个页框</span></span><br><span class="line">    <span class="type">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;      <span class="comment">// 0x100000为低端1M内存</span></span><br><span class="line">    <span class="type">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="type">uint16_t</span> all_free_pages = free_mem / PG_SIZE;          <span class="comment">// 1页为4k,不管总内存是不是4k的倍数,</span></span><br><span class="line">    <span class="comment">// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。</span></span><br><span class="line">    <span class="type">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span></span><br><span class="line">    <span class="type">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;              <span class="comment">// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> ubm_length = user_free_pages / <span class="number">8</span>;              <span class="comment">// User BitMap的长度.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> kp_start = used_mem;                  <span class="comment">// Kernel Pool start,内核内存池的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;      <span class="comment">// User Pool start,用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start = up_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = kernel_free_pages * PG_SIZE;</span><br><span class="line">    user_pool.pool_size = user_free_pages * PG_SIZE;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len = ubm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********    内核内存池和用户内存池位图   ***********</span></span><br><span class="line"><span class="comment">    *   位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    *   全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    *   而我们需要根据总内存大小算出需要多少字节。</span></span><br><span class="line"><span class="comment">    *   所以改为指定一块内存来生成位图.</span></span><br><span class="line"><span class="comment">    *   ************************************************/</span></span><br><span class="line">    <span class="comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span></span><br><span class="line">    <span class="comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="type">void</span>*) MEM_BITMAP_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span></span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="type">void</span>*) (MEM_BITMAP_BASE + kbm_length);</span><br><span class="line">    <span class="comment">/******************** 输出内存池信息 **********************/</span></span><br><span class="line">    put_str(<span class="string">&quot;      kernel_pool_bitmap_start:&quot;</span>);</span><br><span class="line">    put_int((<span class="type">int</span>) kernel_pool.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;      kernel_pool_bitmap_end:&quot;</span>);</span><br><span class="line">    put_int((<span class="type">int</span>) kernel_pool.pool_bitmap.bits + kernel_pool.pool_bitmap.btmp_bytes_len);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;       kernel_pool_phy_addr_start:&quot;</span>);</span><br><span class="line">    put_int(kernel_pool.phy_addr_start);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;       kernel_pool_phy_addr_end:&quot;</span>);</span><br><span class="line">    put_int(kernel_pool.phy_addr_start + kernel_pool.pool_size);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;      user_pool_bitmap_start:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    put_int((<span class="type">int</span>) user_pool.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;      user_pool_bitmap_end:&quot;</span>);</span><br><span class="line">    put_int((<span class="type">int</span>) user_pool.pool_bitmap.bits + user_pool.pool_bitmap.btmp_bytes_len);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;       user_pool_phy_addr_start:&quot;</span>);</span><br><span class="line">    put_int(user_pool.phy_addr_start);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;       user_pool_phy_addr_end:&quot;</span>);</span><br><span class="line">    put_int(user_pool.phy_addr_start + user_pool.pool_size);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将位图置0*/</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span></span><br><span class="line">    <span class="comment">// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="type">void</span>*) (MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    put_str(<span class="string">&quot;     kernel_vaddr.vaddr_bitmap.start:&quot;</span>);</span><br><span class="line">    put_int((<span class="type">int</span>) kernel_vaddr.vaddr_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    put_str(<span class="string">&quot;     kernel_vaddr.vaddr_bitmap.end:&quot;</span>);</span><br><span class="line">    put_int((<span class="type">int</span>) kernel_vaddr.vaddr_bitmap.bits + kernel_vaddr.vaddr_bitmap.btmp_bytes_len);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">&quot;   mem_pool_init done\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 内存管理部分初始化入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;mem_init start\n&quot;</span>);</span><br><span class="line">    <span class="type">uint32_t</span> mem_bytes_total = (*(<span class="type">uint32_t</span> * )(<span class="number">0xb00</span>));</span><br><span class="line">    mem_pool_init(mem_bytes_total);      <span class="comment">// 初始化内存池</span></span><br><span class="line">    put_str(<span class="string">&quot;mem_init done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MEM_BITMAP_BASE</code>用于表示内存位图的基址，其值为<code>0xc009a000</code>。由于 PCB 占用 4KB，内核主线程栈顶<code>0xc009f000</code>，故 PCB 地址为<code>0xc009e00</code>，这里打算支持 4 页位图的内存，故再减去 0x4000,即为所得。位图 1bit 位管理 4KB 内存，一页 4KB 的位图可以管理 128MB 的内存，即最大可管理 512MB 的物理内存。</li>
<li><code>K_HEAP_START</code> 是堆的起始地址，<code>0xc0000000</code>是内核从虚拟地址 3G 起，<code>0x100000</code>意指跨过低端 1M 内存,使虚拟地址在逻辑上连续，故此值为<code>0xc0100000</code>。</li>
<li>函数<code>mem_pool_init</code>是根据内存容量大小初始化<strong>物理内存池</strong>的结构。<ul>
<li>变量<code>page_table_size</code>是指目前分页机制已经占用了多少内存。这里包括一页页目录表+255 个内核空间页表（其中包括第 0 页表项和第 768 页表项指向的同一个页表）。</li>
<li>为了简化位图处理，用 kernel_free_pages 除以 8 获得位图的长度，余数不做处理，故内核内存池和用户内存池各会丢 1-7 页的内存。</li>
</ul>
</li>
<li>在函数<code>mem_init</code>中，第 123 行，使用<code>(*(uint32_t * )(0xb00))</code>获取内存容量，是因为在 loader 中我们将获取到的内存容量保存在<code>total_mem_bytes</code>变量中，其物理地址是 <code>0xb00</code>。</li>
</ul>
<p>要注意的是，位图是全局数据结构，全局或静态的数组需要在编译时知道其长度，而位图的长度取决于具体要管理的内存也数量，因此是无法预计的。所以这里对位图的初始化改为指定一块内存来生成位图，这样就不需要固定长度了。<br>在 makefile 中添加 bitmap 和 memory 的编译：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(BUILD_DIR)</span>/main.o <span class="variable">$(BUILD_DIR)</span>/init.o <span class="variable">$(BUILD_DIR)</span>/interrupt.o \</span><br><span class="line">      <span class="variable">$(BUILD_DIR)</span>/timer.o <span class="variable">$(BUILD_DIR)</span>/kernel.o <span class="variable">$(BUILD_DIR)</span>/print.o \</span><br><span class="line">      <span class="variable">$(BUILD_DIR)</span>/debug.o <span class="variable">$(BUILD_DIR)</span>/string.o <span class="variable">$(BUILD_DIR)</span>/memory.o <span class="variable">$(BUILD_DIR)</span>/bitmap.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/bitmap.o: lib/kernel/bitmap.c lib/kernel/bitmap.h \</span><br><span class="line">    	kernel/global.h lib/stdint.h lib/string.h lib/stdint.h \</span><br><span class="line">     	lib/kernel/print.h kernel/interrupt.h kernel/debug.h</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/memory.o: kernel/memory.c kernel/memory.h lib/stdint.h lib/kernel/bitmap.h \</span><br><span class="line">   	kernel/global.h kernel/global.h kernel/debug.h lib/kernel/print.h \</span><br><span class="line">	lib/kernel/io.h kernel/interrupt.h lib/string.h lib/stdint.h</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1249968/1674197638917-7097b59f-8d4f-4b4e-a983-bc18dae85371.png#averageHue=%23212121&clientId=u17976158-78d5-4&from=paste&height=485&id=uef470582&originHeight=485&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=19307&status=done&style=none&taskId=ud588c663-169d-4ca2-8f87-48ae880d4f1&title=&width=717" alt="image.png"><br>已知物理机 32MB 内存，由图所示，内核物理内存池可分配 15MB，用户物理内存池可分配 15MB，内核物理内存池位图、用户物理内存池位图以及内核虚拟地址位图各占用 480 字节。</p>
<h4 id="8-5-2-内存管理系统第一步，分配页内存"><a href="#8-5-2-内存管理系统第一步，分配页内存" class="headerlink" title="8.5.2 内存管理系统第一步，分配页内存"></a>8.5.2 内存管理系统第一步，分配页内存</h4><p>在上一小节的基础上，对 memory.h 和 memory.c 进行改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内存池标记,用于判断用哪个内存池 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pool_flags</span> &#123;</span></span><br><span class="line">   PF_KERNEL = <span class="number">1</span>,    <span class="comment">// 内核内存池</span></span><br><span class="line">   PF_USER = <span class="number">2</span>	     <span class="comment">// 用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_P_1	  1	<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_P_0	  0	<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_RW_R  0	<span class="comment">// R/W 属性位值, 读/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_RW_W  2	<span class="comment">// R/W 属性位值, 读/写/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_US_S  0	<span class="comment">// U/S 属性位值, 系统级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	 PG_US_U  4	<span class="comment">// U/S 属性位值, 用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">malloc_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br></pre></td></tr></table></figure>

<p>C 语言中申请内存时，由于我们是用户程序，操作系统直接会在用户内存池中分配内存，但这对应对应到内核中具体的操作时，必须要“显式”指定在哪个内存池中申请，故在 memory.h 中新增了枚举结构 pool_flags 来区分这两个内存池。<br>在内存管理中必不可少要修改页表，故这里又定义了一些页表项或页目录项的属性。<br>要注意的是，页表的作用是将虚拟地址转换成物理地址，其转换锅中涉及访问的页目录表、页目录项以及页表项都是通过真是物理地址访问的，若用虚拟地址访问的话会陷入转换的死循环中。<br>memory.c 中新增：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bitmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 在pf表示的虚拟内存池中申请pg_cnt个虚拟页</span></span><br><span class="line"><span class="comment"> * @param pf 内存池类型标志</span></span><br><span class="line"><span class="comment"> * @param pg_cnt 申请内存的页数</span></span><br><span class="line"><span class="comment"> * @return 成功则返回虚拟页的起始地址, 失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">        bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt) &#123;</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 得到虚拟地址vaddr对应的pte指针</span></span><br><span class="line"><span class="comment"> * @param vaddr 虚拟地址</span></span><br><span class="line"><span class="comment"> * @return pte指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> &#123;</span><br><span class="line">    <span class="comment">/* 先访问到页表自己 + \</span></span><br><span class="line"><span class="comment">     * 再用页目录项pde(页目录内页表的索引)做为pte的索引访问到页表 + \</span></span><br><span class="line"><span class="comment">     * 再用pte的索引做为页内偏移*/</span></span><br><span class="line">    <span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + \</span><br><span class="line">	 ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + \</span><br><span class="line">	 PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 得到虚拟地址vaddr对应的pde的指针</span></span><br><span class="line"><span class="comment"> * @param vaddr 虚拟地址</span></span><br><span class="line"><span class="comment"> * @return pde指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> &#123;</span><br><span class="line">    <span class="comment">/* 0xfffff是用来访问到页表本身所在的地址 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 在m_pool指向的物理内存池中分配1个物理页</span></span><br><span class="line"><span class="comment"> * @param m_pool 内存池指针</span></span><br><span class="line"><span class="comment"> * @return 成功则返回页框的物理地址,失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> &#123;</span><br><span class="line">    <span class="comment">/* 扫描或设置位图要保证原子操作 */</span></span><br><span class="line">    <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);    <span class="comment">// 找一个物理页面</span></span><br><span class="line">    <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);	<span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">    <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射</span></span><br><span class="line"><span class="comment"> * @param _vaddr 虚拟地址</span></span><br><span class="line"><span class="comment"> * @param _page_phyaddr 物理地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)_vaddr, page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">    <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">    <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;	 <span class="comment">// 页目录项和页表项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>)) &#123;   <span class="comment">// 只要是创建页表,pte就应该不存在,多判断一下放心</span></span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;			    <span class="comment">//应该不会执行到这，因为上面的ASSERT会先执行。</span></span><br><span class="line">            PANIC(<span class="string">&quot;pte repeat&quot;</span>);</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;			    <span class="comment">// 页目录项不存在,所以要先创建页目录再创建页表项.</span></span><br><span class="line">        <span class="comment">/* 页表中用到的页框一律从内核空间分配 */</span></span><br><span class="line">        <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line"></span><br><span class="line">        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">         * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">         * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">         * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">         * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line"></span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 分配pg_cnt个页空间</span></span><br><span class="line"><span class="comment"> * @param pf 内存池标志</span></span><br><span class="line"><span class="comment"> * @param pg_cnt 页数</span></span><br><span class="line"><span class="comment"> * @return 成功则返回起始虚拟地址,失败时返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);</span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line">    <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) &#123;  <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射</span></span><br><span class="line">        vaddr += PG_SIZE;		 <span class="comment">// 下一个虚拟页</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 从内核物理内存池中申请pg_cnt页内存</span></span><br><span class="line"><span class="comment"> * @param pg_cnt 页数</span></span><br><span class="line"><span class="comment"> * @return 成功则返回其虚拟地址,失败则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>) &#123;	   <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">        <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，函数<code>pte_ptr</code>和<code>pde_ptr</code>都是将虚拟地址赋值给指针，从而触发 CPU 进行寻址操作，从而找到实际 pte 或 pde 的地址。<br>对于函数<code>pte_ptr</code>，pte 指针的值存储在页目录表的指定页目录项中，故重新构造虚拟地址：</p>
<ol>
<li>高 10 位用于定位页目录项。页目录地址保存在最后一个页目录项中，也就是页目录表的第 1023 个目录项地址<code>0xffc00000</code>。</li>
<li>中间 10 位用于定位页表项。存储 pte 的页表项其实就是页目录项，故需要用到 vaddr 的高 10 位，执行<code>(vaddr &amp; 0xffc00000) &gt;&gt; 10</code>。</li>
<li>低 12 位用于定位 pte 地址。在第 2 步中我们定位到存储该 pte 的页表地址，该步需要构造寻址 pte 的页表索引。页表索引即为虚拟地址的中间 10 位，故可直接使用<code>PTE_IDX(vaddr)</code>来获得页表索引，但内存地址低 12 位 CPU 不会自动乘 4，故这里需要手动乘 4 从而得到地址。</li>
</ol>
<p>函数<code>pde_ptr</code>同理。</p>
<blockquote>
<p>注意：直接将低 12 位置 0 取得的是 pte 的值，也就是页表的地址，不是 pte 的地址。pde 同理。</p>
</blockquote>
<p>函数<code>palloc</code>表示物理内存申请，<code>vaddr_get</code>表示虚拟内存申请，<code>page_table_add</code>表示添加虚拟地址和物理地址映射，<code>malloc_page</code>就按照上述顺序执行操作。<br>函数<code>page_table_add</code>不仅完成虚拟地址到物理地址的映射，同时还创建了页目录项、页表、页表项，这里使用页表项的<code>P</code>位属性来判断该页是否在内存中存在。<br>函数<code>malloc_page</code>中考虑到虚拟地址连续但物理地址可能不连续，故一次性申请完虚拟页之后循环申请物理页，每次申请一页，然后再将其关联。<br>最后进行代码测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;I am kernel\n&quot;</span>);</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* addr = get_kernel_pages(<span class="number">3</span>);</span><br><span class="line">    put_str(<span class="string">&quot;\n get_kernel_page start vaddr is &quot;</span>);</span><br><span class="line">    put_int((<span class="type">uint32_t</span>)addr);</span><br><span class="line">    put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后执行：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1249968/1674218661044-d3d869db-1b61-42cb-9309-7826e50d8215.png#averageHue=%23222121&clientId=ud02c3fa3-985a-4&from=paste&height=488&id=u3a5190d7&originHeight=488&originWidth=716&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=20135&status=done&style=none&taskId=u742f5d7a-aca6-4b68-a116-f35da4e0867&title=&width=716" alt="image.png"><br>使用<code>page 0xc0100000</code>命令可以看到虚拟内存映射情况：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1249968/1674219065652-74c40226-77dc-4b8e-b36f-76ebf8c3772f.png#averageHue=%23300b26&clientId=ud02c3fa3-985a-4&from=paste&height=54&id=u33078f6e&originHeight=72&originWidth=622&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15778&status=done&style=none&taskId=u7fb1dd19-b367-4e6f-bfb6-8bf78a42fa6&title=&width=467" alt="image.png"><br>虚拟地址范围为<code>0xc0100000</code>-<code>0xc0102fff</code>，其所映射的物理地址范围为<code>0x200000</code>-<code>0x202fff</code>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1249968/1674219217197-53b2fc20-7160-407a-aa54-fbd7c017d9c9.png#averageHue=%233b2766&clientId=ud02c3fa3-985a-4&from=paste&height=119&id=ufd44da24&originHeight=158&originWidth=640&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16136&status=done&style=none&taskId=u601e4e15-586a-491d-853a-4d6e5caa2b7&title=&width=480" alt="image.png"><br>本章结束。</p>
<blockquote>
<p>本章残留问题：未实现内存回收，将在第 12 章时完善。</p>
</blockquote>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2023/06/23/yuque/tgft5m5mgh787k7d/" title="硬件虚拟化" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">
								《操作系统真象还原》：第七章 中断			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 25日, 2022				
							</p>
							<p class="relate-post-content">
								7.1 中断是什么，为什么要有中断运用中断能够显著提升并发，从而大幅提升效率。
7.2 操作系统是中断驱动的略
7.3 中断分类把中断按事件来源分类，来自 CPU 外部的中断就称为外部中断，来自 CPU 内部的中断称为内部中断。外部中...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第七章 中断"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">
								《操作系统真象还原》：第六章 完善内核			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 18日, 2022				
							</p>
							<p class="relate-post-content">
								6.1 函数调用约定简介咱们实验使用cdecl。这里提一下stdcall，cdecl与stdcall的区别在于由谁来回收栈空间。stdcall是被调用者清理参数所占的栈空间。举例来说：
12int subtract(int a, in...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第六章 完善内核"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" title="《操作系统真象还原》：第五章 保护模式进阶——加载内核">
								《操作系统真象还原》：第五章 保护模式进阶——加载内核			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 11日, 2022				
							</p>
							<p class="relate-post-content">
								5.3 加载内核5.3.1 用 C 语言写内核第一个 C 语言代码：
1234int main(void) &#123;	while(1);	return 0;&#125;

这个内核文件什么都没做，通过while(1)这个死循环一直...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" title="《操作系统真象还原》：第五章 保护模式进阶——加载内核">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第五章 保护模式进阶——加载内核"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">
								《操作系统真象还原》：第五章 保护模式进阶——内存分页机制			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 19日, 2022				
							</p>
							<p class="relate-post-content">
								
从这一刻起，我们才算开始了真正的操作系统学习之旅

5.1 获取物理内存容量5.1.1 Linux 获取内存的方法在 Linux 2.6 内核总是用detect_memory函数来获取内存容量的。其函数子啊本质上是通过调用 BIOS...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">
								《操作系统真象还原》：第四章 保护模式入门			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 8日, 2022				
							</p>
							<p class="relate-post-content">
								4.1 保护模式概述在本章大家会见到全局描述符表、中断描述符表、各种门结构，这是 CPU 提供给应用的，咱们用好就行。保护模式强调的是“保护”，它是在 Intel 80286 CPU 中首次出现，这是继 8086 之后，Intel 紧...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第四章 保护模式入门"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">
								《操作系统真象还原》：第三章 完善MBR——I/O接口			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 25日, 2022				
							</p>
							<p class="relate-post-content">
								3.3 让我们对显示器说点什么吧3.3.1 CPU 如何与外设通信——IO 接口IO 接口功能：

设置数据缓冲，解决 CPU 与外设的速度不匹配
设置信号电平转换电路
设置数据格式转换
设置时序控制电路来同步 CPU 和外部设备
提...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第三章 完善MBR——I/O接口"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/11/yuque/xa16pm/" title="《操作系统真象还原》：第三章 完善MBR——CPU的实模式">
								《操作系统真象还原》：第三章 完善MBR——CPU的实模式			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 11日, 2022				
							</p>
							<p class="relate-post-content">
								针对汇编几个知识点：

第 1 行和第 4 行的 mov 操作，机器码第 1 个宇节都是B8，而另外第 2、3 行同样是 mov 指令，机器码却有天壤之别，似乎找不到共性。原因是机器码是由很多部分组成的，比如指令前缀、主操作码字节以及...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/11/yuque/xa16pm/" title="《操作系统真象还原》：第三章 完善MBR——CPU的实模式">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第三章 完善MBR——CPU的实模式"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/05/23/yuque/bfwmot/" title="《操作系统真象还原》：第二章 编写 MBR">
								《操作系统真象还原》：第二章 编写 MBR			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 23日, 2022				
							</p>
							<p class="relate-post-content">
								先了解 CPU 的两种工作模式：实模式和保护模式实模式（英语：Real mode）是 Intel 80286 和之后的 x86 兼容 CPU 的操作模式。实模式的特性是一个 20 比特的区段存储器地址空间（意思为只有 1MB 的存储器...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/05/23/yuque/bfwmot/" title="《操作系统真象还原》：第二章 编写 MBR">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第二章 编写 MBR"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/05/09/yuque/wx4152/" title="《操作系统真象还原》：第一章 环境配置">
								《操作系统真象还原》：第一章 环境配置			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 9日, 2022				
							</p>
							<p class="relate-post-content">
								第 0 章：一些你可能正感到迷惑的问题
摘记

0.28 MBR、EBR、DBR 和 OBR 各是什么MBR 位于整个硬盘最开始的块， EBR 位于每个子扩展分区，各子扩展分区中只有一个逻辑分区。 MBR 和 EBR 位于分区之外的扇...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/05/09/yuque/wx4152/" title="《操作系统真象还原》：第一章 环境配置">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第一章 环境配置"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/06/16/yuque/dlziqz/" title="6月阅读总结">
								6月阅读总结			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 16日, 2022				
							</p>
							<p class="relate-post-content">
								
“零拷贝”技术
Sogou C++ Workflow：搜狗公司的 C++服务器引擎，支持 500k QPS
Reducing CPU scheduler latency in Linux：CPU 调度算法 BMQ 和 CFS 的对比...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/06/16/yuque/dlziqz/" title="6月阅读总结">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="6月阅读总结"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	

		

			<!-- gitalk comment -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">

	(function gitalkComment(){
		//Thanks O-R
		//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
		//去除尾部匹配正则数组的字符串  
		//Remove redundant characters
		String.prototype.trimEnd = function(regStr) {
			let result = this;
			if(regStr == undefined || regStr == null || regStr == "") {
				return result;
			}
			let array = regStr.split(',');

			if(array.length > 0) {

				let c = array.shift(), 
					str = this,
					i = str.length,
					rg = new RegExp(c),
					matchArr = str.match(rg);

				if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
					let matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
						.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
						.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
						.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
						.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
						.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
						.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
						.replace(/\./g, "\\.").replace(/\&/g, "\\&");
					matchStr = matchStr + '$';
					result = str.replace(new RegExp(matchStr), "");
				}

				if(array.length > 0) {
					return result.trimEnd(array.join())
				} else {
					return result;
				}
			}
		};

		//Create gitalk
		let gitalk = new Gitalk({
			clientID: '693063c1941dbc1701d3',
			clientSecret: 'f88ddf502ef33ce91ce9d8c140dbc7e3a0653b7e',
			//id: window.location.pathname,
			//id: decodeURI(window.location.pathname),
			//id: (window.location.pathname).split("/").pop().substring(0, 49),
			id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
			repo: 'lisongqian.github.io',
			owner: 'lisongqian',
			admin: 'lisongqian',
			distractionFreeMode: 'false',
		})
		gitalk.render('gitalk-container');		
	})();
</script>

		
		
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>

	<div class="copyright">
		<p>
		<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">鲁ICP备16042410号</a>
			 
				&copy;2017 - 2024, content by SongqianLi. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		

<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>




<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  

	<!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup scrollbar" >
	<div class="local-search-container">
		<span class="popup-btn-close">
      		ESC
   		</span>
		<div class="local-search-header">
			<div class="input-prompt">				
			</div>
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			<div class="topN-post">				
				
								
			</div>
		</div>
	</div>
</div>


<script src="/plugin/search/ziploader.js"></script>
<script src="/js/search.js"></script>


<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>