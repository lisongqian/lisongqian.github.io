<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      《操作系统真象还原》：第十章 输入输出系统 | Songqian Li&#39;s Blog
    
  </title>
  <meta name="author" content="Songqian Li">
  <meta name="keywords" content="" />
  <meta name="description" content="去历史上留点故事" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">
<!--  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900">-->
  <link rel="stylesheet" href="https://fonts.font.im/css?family=Playfair+Display:400,700,900">
  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: false
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'L0W62cCkHAgT0VsIX6WztMhp-gzGzoHsz',
	  appKey: 'n1lX9eWfotXltQ6Cab3ngGfk',
	  serverURLs: 'https://l0w62cck.lc-cn-n1-shared.com' || ' '
    }
  </script>
  <!-- site analysis -->
  

	<!-- site-analysis -->
	
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "//hm.baidu.com/hm.js?b702b9b0aa72233c214dcbade17a5a27";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	
	
	
	
 
    <meta name="referrer" content="no-referrer"/>
<meta name="generator" content="Hexo 6.3.0"></head>
	<body>
		<!-- Preloader -->


<!-- header -->
<header class="fixbackground">
		<div class="header-wrapper">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	<div class="mask">
	<div class="banner-frame border-image" style="border-image-source: url('/img/mask.png');"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-12">
					<div class="align">
						<h1 class="h1 light">Songqian Li&#39;s Blog</h1>
						<div class="empty-space col-xs-b15"></div>
						<div class="sa light large">去历史上留点故事</div>
						<div class="empty-space col-xs-b30"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- motto -->
		<div class="h-body">	
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「《操作系统真象还原》：第十章 输入输出系统」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<!--<span class="logo"> 
			<img src="/img/logo.png">
		</span> -->
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="//github.com/lisongqian" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2024/01/08/yuque/wutni9yzkuq6y0n7/" itemprop="url">
		《操作系统真象还原》：第十章 输入输出系统
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2024/01/08/yuque/wutni9yzkuq6y0n7/" itemprop="url">
		<time datetime="2024-01-08T13:43:26.000Z" itemprop="dateUpdated">
	  		2024-01-09
	  </time>
	</a> 



			</span>
			<span>
						
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<blockquote>
<p>上一章中我们遇到的字符混乱和 GP 异常问题，根本原因是由于临界区代码的资源竞争，这需要一些互斥的方法来保证操作的原子性。</p>
</blockquote>
<h3 id="101-同步机制锁"><a class="markdownIt-Anchor" href="#101-同步机制锁"></a> 10.1 同步机制——锁</h3>
<h4 id="1011-排查-gp-异常理解原子操作"><a class="markdownIt-Anchor" href="#1011-排查-gp-异常理解原子操作"></a> 10.1.1 排查 GP 异常，理解原子操作</h4>
<p>多线程执行刷屏时光标值越界导致 GP 异常。</p>
<h4 id="1012-找出代码中的临界区-互斥-竞争条件"><a class="markdownIt-Anchor" href="#1012-找出代码中的临界区-互斥-竞争条件"></a> 10.1.2 找出代码中的临界区、互斥、竞争条件</h4>
<p>公共资源：“显存”<br />
临界区：put_char 的多个指令</p>
<h4 id="1013-信号量"><a class="markdownIt-Anchor" href="#1013-信号量"></a> 10.1.3 信号量</h4>
<p>信号量是个计数器，它的计数值是自然数，用来记录所积累信号的数量。<br />
对于信号量的增减方法用 P、V 操作来表示，P 表示减少，V 表示增加。<br />
P 操作（书中为减少操作 down）包括：</p>
<ol>
<li>判断信号量是否大于 0；</li>
<li>若大于 0 则加 1；</li>
<li>若等于 0 则阻塞；</li>
</ol>
<p>V 操作（书中为增加操作 up）包括：</p>
<ol>
<li>将信号量的值加 1；</li>
<li>唤醒在此信号量上等待的线程；</li>
</ol>
<p>若信号量初值为 1，它的取值就只能为 0 和 1，这成为二元信号量，可以利用二元信号量来实现锁。</p>
<h4 id="1014-线程的阻塞和唤醒"><a class="markdownIt-Anchor" href="#1014-线程的阻塞和唤醒"></a> 10.1.4 线程的阻塞和唤醒</h4>
<p>本节实现线程阻塞函数<code>thread_block</code>和线程唤醒函数<code>thread_unblock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程将自己阻塞,标志其状态为stat.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_block</span><span class="params">(<span class="keyword">enum</span> task_status stat)</span> &#123;</span><br><span class="line"><span class="comment">/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/</span></span><br><span class="line">    ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line">    cur_thread-&gt;status = stat; <span class="comment">// 置其状态为stat</span></span><br><span class="line">    schedule();		      <span class="comment">// 将当前线程换下处理器</span></span><br><span class="line"><span class="comment">/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将线程pthread解除阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_unblock</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    ASSERT(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));</span><br><span class="line">    <span class="keyword">if</span> (pthread-&gt;status != TASK_READY) &#123;</span><br><span class="line">        ASSERT(!elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag));</span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag)) &#123;</span><br><span class="line">            PANIC(<span class="string">&quot;thread_unblock: blocked thread in ready_list\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>thread_block</code>来说，阻塞线程只需要将当前线程换下 CPU 并不放入就绪队列。<br />
而对于<code>thread_unblock</code>来说，被阻塞的线程无法唤醒自己，需要被其他线程唤醒，所以参数 pthread 指向的是目前已经被阻塞，又希望被唤醒的线程。</p>
<h4 id="1015-锁的实现"><a class="markdownIt-Anchor" href="#1015-锁的实现"></a> 10.1.5 锁的实现</h4>
<p>本节会实现信号量和锁。<br />
我们创建 thread/sync.h：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THREAD_SYNC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __THREAD_SYNC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">   <span class="type">uint8_t</span>  value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">list</span> <span class="title">waiters</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 锁结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">task_struct</span>* <span class="title">holder</span>;</span>	    <span class="comment">// 锁的持有者</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span>	    <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">   <span class="type">uint32_t</span> holder_repeat_nr;		    <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>和 thread/sync.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sync.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化信号量 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">   psema-&gt;value = value;       <span class="comment">// 为信号量赋初值</span></span><br><span class="line">   list_init(&amp;psema-&gt;waiters); <span class="comment">//初始化信号量的等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">   plock-&gt;holder = <span class="literal">NULL</span>;</span><br><span class="line">   plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">   sema_init(&amp;plock-&gt;semaphore, <span class="number">1</span>);  <span class="comment">// 信号量初值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">   <span class="keyword">while</span>(psema-&gt;value == <span class="number">0</span>) &#123;	<span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">      ASSERT(!elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag));</span><br><span class="line">      <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">      <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag)) &#123;</span><br><span class="line">	 PANIC(<span class="string">&quot;sema_down: thread blocked has been in waiters_list\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">      list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);</span><br><span class="line">      thread_block(TASK_BLOCKED);    <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">   psema-&gt;value--;</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters)) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread_blocked</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));</span><br><span class="line">      thread_unblock(thread_blocked);</span><br><span class="line">   &#125;</span><br><span class="line">   psema-&gt;value++;</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line"><span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">   <span class="keyword">if</span> (plock-&gt;holder != running_thread()) &#123;</span><br><span class="line">      sema_down(&amp;plock-&gt;semaphore);    <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">      plock-&gt;holder = running_thread();</span><br><span class="line">      ASSERT(plock-&gt;holder_repeat_nr == <span class="number">0</span>);</span><br><span class="line">      plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      plock-&gt;holder_repeat_nr++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">   ASSERT(plock-&gt;holder == running_thread());</span><br><span class="line">   <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      plock-&gt;holder_repeat_nr--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(plock-&gt;holder_repeat_nr == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   plock-&gt;holder = <span class="literal">NULL</span>;	   <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">   plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">   sema_up(&amp;plock-&gt;semaphore);	   <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>信号量 down 操作：</p>
<ol>
<li>信号量&gt;0 时，把信号量-1，恢复中断；</li>
<li>信号量=0 时，把当前线程加入信号量的等待队列，然后阻塞自己；</li>
</ol>
<p>信号量 up 操作：获取阻塞线程，将其唤醒，同时信号量+1。</p>
<h3 id="102-用锁实现终端输出"><a class="markdownIt-Anchor" href="#102-用锁实现终端输出"></a> 10.2 用锁实现终端输出</h3>
<p>tty 表示终端，我们登录系统后，就会在后台运行一个 tty 进程，相当于一个虚拟终端。虚拟终端通过向显卡的&quot;Start Address High Register&quot;和&quot;Start Address Low Register&quot;设置不同的 16 位地址实现显存分块显示，也就是实现多个虚拟终端。<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704465441463-ad62e273-dc32-456b-95cc-25e86398027e.png#averageHue=%23ebebeb&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=235&amp;id=uaca07d91&amp;originHeight=352&amp;originWidth=435&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=69634&amp;status=done&amp;style=none&amp;taskId=uea17da6e-9aca-47eb-9978-8eee9d18aed&amp;title=&amp;width=290" alt="image.png" /><br />
这里要提一下，通过 ssh 登录的终端称为 pts，可以通过 who 命令输出 tty 还是 pts 来判断用户是否为远程登录。<br />
本节没有实现终端，只是互斥访问一个终端。<br />
device/console.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DEVICE_CONSOLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEVICE_CONSOLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>device/console.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sync.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">// 控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span> &#123;</span><br><span class="line">    lock_init(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">()</span> &#123;</span><br><span class="line">    lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">()</span> &#123;</span><br><span class="line">    lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出字符串 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_str(str);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出字符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci)</span> &#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_char(char_asci);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出16进制整数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num)</span> &#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_int(num);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在<strong>init.c</strong>中添加上<code>console_init();</code>，将<strong>main.c</strong>的 while 循环里的<code>put_str</code>函数改为<code>console_put_str</code>，运行测试：<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704467513432-966cbea9-72f1-4051-866d-b6a33f0bce38.png#averageHue=%23343434&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=325&amp;id=u6bb870f7&amp;originHeight=488&amp;originWidth=714&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=20080&amp;status=done&amp;style=none&amp;taskId=u235acaf7-ff07-4146-8206-a1d61b48e57&amp;title=&amp;width=476" alt="image.png" /></p>
<h3 id="103-从键盘获取输入"><a class="markdownIt-Anchor" href="#103-从键盘获取输入"></a> 10.3 从键盘获取输入</h3>
<h4 id="1031-键盘输入原理简介"><a class="markdownIt-Anchor" href="#1031-键盘输入原理简介"></a> 10.3.1 键盘输入原理简介</h4>
<p>键盘是个独立的设备，其内部有个叫做键盘编码器的芯片，通常是 Intel 8048 或兼容芯片，每当键盘发生按键操作，键盘编码器就向键盘控制器报告。<br />
键盘控制器在主机内部的主板上，通常是 Intel 8042 或兼容芯片，用于接收来自键盘编码器的按键信息并解码保存，然后向中断代理发中断，之后处理器执行相应的中断处理程序读入 8042 处理保存过的按键信息。<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704508494561-8c5029a8-2917-431c-b278-b8993c982523.png#averageHue=%23e7e7e7&amp;clientId=u589813db-0770-4&amp;from=paste&amp;id=u2c45cc01&amp;originHeight=375&amp;originWidth=515&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=74254&amp;status=done&amp;style=none&amp;taskId=u0376c7cb-fa12-404c-a8b2-17006a93423&amp;title=" alt="image.png" /><br />
键盘上所有按键都有自己的编码，每个按键都会分配唯一的数字，这个记录“按键-数值”的编码映射表称为键盘扫描码。<br />
同时，按键的状态有按下和弹起，所以一个键有两个编码，按键按下的编码叫通码（makecode），弹起的叫断码（breakcode）。</p>
<h4 id="1032-键盘扫描码"><a class="markdownIt-Anchor" href="#1032-键盘扫描码"></a> 10.3.2 键盘扫描码</h4>
<p>根据不同的编码方案，键盘扫描码有三套：scan code set 1、scan code set 2、scan code set 3.<br />
第一套扫描码是 XT 键盘所用的扫描码，这是最早的键盘编码：<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704511088566-04decf26-926c-4bc4-8933-965c4bd3684d.png#averageHue=%23bababa&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=164&amp;id=ucd6f68be&amp;originHeight=246&amp;originWidth=774&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=226037&amp;status=done&amp;style=none&amp;taskId=u111dcfc8-0b59-4435-a22b-99a276fbd39&amp;title=&amp;width=516" alt="image.png" /><br />
第二套是 AT 键盘的扫描码，也是目前常用的扫描码：<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704511149374-7a74702e-184f-4218-8cb9-58395216d31c.png#averageHue=%23ababab&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=162&amp;id=u86dfb027&amp;originHeight=243&amp;originWidth=799&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=252390&amp;status=done&amp;style=none&amp;taskId=u3f039d60-04c7-4d87-a596-8c081dd1276&amp;title=&amp;width=532.6666666666666" alt="image.png" /><br />
第三套是 IBM PS/2 系列计算机使用的键盘扫描码，不过这种键盘已经很少看到了：<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704511215698-893ef11b-5e43-4009-8b90-ac6ada5b0ab5.png#averageHue=%238a8a8a&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=255&amp;id=ube1618c7&amp;originHeight=382&amp;originWidth=1038&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=354556&amp;status=done&amp;style=none&amp;taskId=ufc622b8b-3088-44e6-a891-522f4ddb5dd&amp;title=&amp;width=692" alt="image.png" /><br />
无论使用哪套扫描码，为了兼容，在 8042 中都会转换成第一套扫描码来使用。<br />
大多数情况下第一套扫描码中的通码和断码都是 1 字节大小，且<strong>断码= 0x80+通码</strong>。<br />
第二套扫描码一般通码是 1 字节大小，断码是在通码前再加 1 字节的 0xf0，共 2 字节。<br />
有些键是 0xe0 作为前缀，不为 1 字节，这类是后来扩展进来的按键。<br />
Intel 8042 的输出缓冲区寄存器只有 8 位宽度，所以每收到 1 字节扫描码就会向中断代理发送中断信号。<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704530367538-80e6071e-eed4-4e19-aa0f-b15d9a4f7d92.png#averageHue=%23d7d7d7&amp;clientId=u589813db-0770-4&amp;from=paste&amp;id=uc98f1793&amp;originHeight=400&amp;originWidth=430&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=187472&amp;status=done&amp;style=none&amp;taskId=u6545661c-b299-4746-8670-1af458e2f0e&amp;title=" alt="image.png" /><br />
这里放了两套扫描码方便对比和“假设”。</p>
<h4 id="1033-8042-简介"><a class="markdownIt-Anchor" href="#1033-8042-简介"></a> 10.3.3 8042 简介</h4>
<p>和键盘相关的芯片只有 8042 和 8048，它们都是独立的处理器，都有自己的寄存器和内存。<br />
Intel 8042 芯片或兼容芯片被集成在主板上的南桥芯片中，它是键盘控制器，也就是键盘的 IO 接口，<br />
因此它是 8048 的代理。键盘编码器 8048 芯片通过 PS/2、USB 等接口与 8042 通信，处理器通过接口与 8042 通信。<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704531564092-f8f908c1-b069-4372-8856-9d5cdb082b23.png#averageHue=%23e8e8e8&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=180&amp;id=u538cadd5&amp;originHeight=270&amp;originWidth=1401&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=137913&amp;status=done&amp;style=none&amp;taskId=u657634b1-d09b-43d2-8bb3-61e755ea7a6&amp;title=&amp;width=934" alt="image.png" /><br />
8042 寄存器如上表所示，可以实现两个功能：</p>
<ul>
<li>当需要把数据从处理器发到 8042 时 （数据传送尚未发生时）， 0x60 端口的作用是输入缓冲区，此时应该用 out 指令写入 0x60 端口。</li>
<li>当数据己从 8048 发到 8042 时， 0x60 端口的作用是输出缓冲区，此时应该用 in 指令从 8042 的 0x60 端口（输出缓冲区寄存器〉读取 8048 的输出结果。</li>
</ul>
<p>其中状态寄存器（8 位，只读）的作用：</p>
<ol>
<li>位 0：置 1 时表示输出缓冲区寄存器己满，处理器通过 m 指令读取后该位自动置 0 。</li>
<li>位 1：置 1 时表示输入缓冲区寄存器己满， 8042 将值读取后该位自动置 0。</li>
<li>位 2：系统标志位，最初加电时为 0，自检通过后置为 1 。</li>
<li>位 3：置 1 时，表示输入缓冲区中的内容是命令，置 0 时，输入缓冲区中的内容是普通数据。</li>
<li>位 4：置 1 时表示键盘启用，置 0 时表示键盘禁用。</li>
<li>位 5：置 1 时表示发送超时。</li>
<li>位 6：置 1 时表示接收超时。</li>
<li>位 7：来自 8048 的数据在奇偶校验时出错。</li>
</ol>
<p>控制寄存器（8 位，只写）的作用：</p>
<ol>
<li>位 0：置 1 时启用键盘中断。</li>
<li>位 1 ：置 1 时启用鼠标中断。</li>
<li>位 2：设置状态寄存器的位 2 。</li>
<li>位 3：置 1 时，状态寄存器的位 4 无效。</li>
<li>位 4：置 1 时禁止键盘。</li>
<li>位 5：置 1 时禁止鼠标。</li>
<li>位 6：将第二套键盘扫描码转换为第一套键盘扫描码。</li>
<li>位 7：保留位，默认为 0 。</li>
</ol>
<h4 id="1034-测试键盘中断处理程序"><a class="markdownIt-Anchor" href="#1034-测试键盘中断处理程序"></a> 10.3.4 测试键盘中断处理程序</h4>
<p>本节完成一个键盘中断处理程序。<br />
首先添加足够的中断向量号，在 kernel/kernel.S 中添加：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VECTOR <span class="number">0</span>x20, ZERO	;时钟中断对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x21, ZERO	;键盘中断对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x22, ZERO	;级联用的</span><br><span class="line">VECTOR <span class="number">0</span>x23, ZERO	;串口<span class="number">2</span>对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x24, ZERO	;串口<span class="number">1</span>对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x25, ZERO	;并口<span class="number">2</span>对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x26, ZERO	;软盘对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x27, ZERO	;并口<span class="number">1</span>对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x28, ZERO	;实时时钟对应的入口</span><br><span class="line">VECTOR <span class="number">0</span>x29, ZERO	;重定向</span><br><span class="line">VECTOR <span class="number">0</span>x2a, ZERO	;保留</span><br><span class="line">VECTOR <span class="number">0</span>x2b, ZERO	;保留</span><br><span class="line">VECTOR <span class="number">0</span>x2c, ZERO	;ps/<span class="number">2</span>鼠标</span><br><span class="line">VECTOR <span class="number">0</span>x2d, ZERO	;fpu浮点单元异常</span><br><span class="line">VECTOR <span class="number">0</span>x2e, ZERO	;硬盘</span><br><span class="line">VECTOR <span class="number">0</span>x2f, ZERO	;保留</span><br></pre></td></tr></table></figure>
<p>这 16 个中断向量号正好对应两个 8259A 芯片的 16 个引脚，有关 8259A 的介绍见<a target="_blank" rel="noopener" href="https://blog.lisongqian.cn/2022/12/25/yuque/gf0t07d01kr4oe9r/">《操作系统真象还原》：第七章 中断 | Songqian Li’s Blog</a>。<br />
添加完中断向量号后，需要在中断描述符表中注册中断入口程序。我们需要先更改<code>IDT_DESC_CNT</code>的值即目前支持的总中断数为<code>0x30</code>，然后开启 8259A 对键盘中断的屏蔽：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outb(PIC_M_DATA, <span class="number">0xfc</span>);        <span class="comment">//OCW1: 1111 1100</span></span><br></pre></td></tr></table></figure>
<p>同时在 init.c 中加入<code>keyboard_init()</code>函数，为了显示直观，可以注释掉在 main.c 中的输出代码。最终运行得到：<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704555279598-ebbd8667-dd94-4c22-b962-7d6f847c4b42.png#averageHue=%2320201f&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=321&amp;id=uebfe10d5&amp;originHeight=482&amp;originWidth=718&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=18729&amp;status=done&amp;style=none&amp;taskId=ua7332006-0f4c-463c-97ca-2489124f8bc&amp;title=&amp;width=478.6666666666667" alt="image.png" /></p>
<h3 id="104-编写键盘驱动"><a class="markdownIt-Anchor" href="#104-编写键盘驱动"></a> 10.4 编写键盘驱动</h3>
<p>本节将编写键盘中断处理程序。</p>
<h4 id="1041-转义字符介绍"><a class="markdownIt-Anchor" href="#1041-转义字符介绍"></a> 10.4.1 转义字符介绍</h4>
<p>C 语言中有三种转移字符：</p>
<ol>
<li>一般转义字符，'+单个字母’的形式。</li>
<li>八进制转义字符，'\0+三位八进制数字表示的 ASCII 码形式。</li>
<li>十六进制转义字符，‘\x+两位十六进制数字表示的 ASCII 码’ 的形式。</li>
</ol>
<h4 id="1042-处理扫描码"><a class="markdownIt-Anchor" href="#1042-处理扫描码"></a> 10.4.2 处理扫描码</h4>
<ol>
<li>对于控制键，例如<shift>、<ctrl>等，它通常是组合键，需要与其他键一起考虑然后做出具体的行为，在键盘驱动中完成处理。</li>
<li>对于字符方面的键，统统交给字符处理程序完成。</li>
</ol>
<p>首先在 keyboard.c 中添加按键的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用转义字符定义部分控制字符 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esc		<span class="string">&#x27;\033&#x27;</span>	 <span class="comment">// 八进制表示字符,也可以用十六进制&#x27;\x1b&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> backspace	<span class="string">&#x27;\b&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tab		<span class="string">&#x27;\t&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter		<span class="string">&#x27;\r&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> delete		<span class="string">&#x27;\177&#x27;</span>	 <span class="comment">// 八进制表示字符,十六进制为&#x27;\x7f&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以上不可见字符一律定义为0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> char_invisible	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ctrl_l_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ctrl_r_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> shift_l_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> shift_r_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alt_l_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alt_r_char	char_invisible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> caps_lock_char	char_invisible</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义控制字符的通码和断码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> shift_l_make	0x2a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> shift_r_make 	0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alt_l_make   	0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alt_r_make   	0xe038</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alt_r_break   	0xe0b8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ctrl_l_make  	0x1d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ctrl_r_make  	0xe01d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ctrl_r_break 	0xe09d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> caps_lock_make 	0x3a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义以下变量记录相应键是否按下的状态,</span></span><br><span class="line"><span class="comment"> * ext_scancode用于记录makecode是否以0xe0开头 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;</span><br></pre></td></tr></table></figure>
<p>然后修改键盘中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 键盘中断处理程序 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intr_keyboard_handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */</span></span><br><span class="line">    <span class="type">bool</span> ctrl_down_last = ctrl_status;</span><br><span class="line">    <span class="type">bool</span> shift_down_last = shift_status;</span><br><span class="line">    <span class="type">bool</span> caps_lock_last = caps_lock_status;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> break_code;</span><br><span class="line">    <span class="type">uint16_t</span> scancode = inb(KBD_BUF_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,</span></span><br><span class="line"><span class="comment"> * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/</span></span><br><span class="line">    <span class="keyword">if</span> (scancode == <span class="number">0xe0</span>) &#123;</span><br><span class="line">        ext_scancode = <span class="literal">true</span>;    <span class="comment">// 打开e0标记</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果上次是以0xe0开头,将扫描码合并 */</span></span><br><span class="line">    <span class="keyword">if</span> (ext_scancode) &#123;</span><br><span class="line">        scancode = ((<span class="number">0xe000</span>) | scancode);</span><br><span class="line">        ext_scancode = <span class="literal">false</span>;   <span class="comment">// 关闭e0标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    break_code = ((scancode &amp; <span class="number">0x0080</span>) != <span class="number">0</span>);   <span class="comment">// 获取break_code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (break_code) &#123;   <span class="comment">// 若是断码break_code(按键弹起时产生的扫描码)</span></span><br><span class="line">        <span class="comment">/* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,</span></span><br><span class="line"><span class="comment">        所以可用下面的方法取make_code,多字节的扫描码暂不处理 */</span></span><br><span class="line">        <span class="type">uint16_t</span> make_code = (scancode &amp;= <span class="number">0xff7f</span>);   <span class="comment">// 得到其make_code(按键按下时产生的扫描码)</span></span><br><span class="line">        <span class="comment">/* 若是任意以下三个键弹起了,将状态置为false */</span></span><br><span class="line">        <span class="keyword">if</span> (make_code == ctrl_l_make || make_code == ctrl_r_make) &#123;</span><br><span class="line">            ctrl_status = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (make_code == shift_l_make || make_code == shift_r_make) &#123;</span><br><span class="line">            shift_status = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (make_code == alt_l_make || make_code == alt_r_make) &#123;</span><br><span class="line">            alt_status = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="comment">/* 由于caps_lock不是弹起后关闭,所以需要单独处理 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((scancode &gt; <span class="number">0x00</span> &amp;&amp; scancode &lt; <span class="number">0x3b</span>) || \</span><br><span class="line">	       (scancode == alt_r_make) || \</span><br><span class="line">	       (scancode == ctrl_r_make)) &#123;</span><br><span class="line">        <span class="type">bool</span> shift = <span class="literal">false</span>;  <span class="comment">// 判断是否与shift组合,用来在一维数组中索引对应的字符</span></span><br><span class="line">        <span class="keyword">if</span> ((scancode &lt; <span class="number">0x0e</span>) || (scancode == <span class="number">0x29</span>) || \</span><br><span class="line">	 (scancode == <span class="number">0x1a</span>) || (scancode == <span class="number">0x1b</span>) || \</span><br><span class="line">	 (scancode == <span class="number">0x2b</span>) || (scancode == <span class="number">0x27</span>) || \</span><br><span class="line">	 (scancode == <span class="number">0x28</span>) || (scancode == <span class="number">0x33</span>) || \</span><br><span class="line">	 (scancode == <span class="number">0x34</span>) || (scancode == <span class="number">0x35</span>)) &#123;</span><br><span class="line">            <span class="comment">/****** 代表两个字母的键 ********</span></span><br><span class="line"><span class="comment">                 0x0e 数字&#x27;0&#x27;~&#x27;9&#x27;,字符&#x27;-&#x27;,字符&#x27;=&#x27;</span></span><br><span class="line"><span class="comment">                 0x29 字符&#x27;`&#x27;</span></span><br><span class="line"><span class="comment">                 0x1a 字符&#x27;[&#x27;</span></span><br><span class="line"><span class="comment">                 0x1b 字符&#x27;]&#x27;</span></span><br><span class="line"><span class="comment">                 0x2b 字符&#x27;\\&#x27;</span></span><br><span class="line"><span class="comment">                 0x27 字符&#x27;;&#x27;</span></span><br><span class="line"><span class="comment">                 0x28 字符&#x27;\&#x27;&#x27;</span></span><br><span class="line"><span class="comment">                 0x33 字符&#x27;,&#x27;</span></span><br><span class="line"><span class="comment">                 0x34 字符&#x27;.&#x27;</span></span><br><span class="line"><span class="comment">                 0x35 字符&#x27;/&#x27;</span></span><br><span class="line"><span class="comment">            *******************************/</span></span><br><span class="line">            <span class="keyword">if</span> (shift_down_last) &#123;  <span class="comment">// 如果同时按下了shift键</span></span><br><span class="line">                shift = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	  <span class="comment">// 默认为字母键</span></span><br><span class="line">            <span class="keyword">if</span> (shift_down_last &amp;&amp; caps_lock_last) &#123;  <span class="comment">// 如果shift和capslock同时按下</span></span><br><span class="line">                shift = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift_down_last || caps_lock_last) &#123; <span class="comment">// 如果shift和capslock任意被按下</span></span><br><span class="line">                shift = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                shift = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint8_t</span> index = (scancode &amp;= <span class="number">0x00ff</span>);  <span class="comment">// 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.</span></span><br><span class="line">        <span class="type">char</span> cur_char = keymap[index][shift];  <span class="comment">// 在数组中找到对应的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 只处理ascii码不为0的键 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_char) &#123;</span><br><span class="line">            put_char(cur_char);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */</span></span><br><span class="line">        <span class="keyword">if</span> (scancode == ctrl_l_make || scancode == ctrl_r_make) &#123;</span><br><span class="line">            ctrl_status = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scancode == shift_l_make || scancode == shift_r_make) &#123;</span><br><span class="line">            shift_status = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scancode == alt_l_make || scancode == alt_r_make) &#123;</span><br><span class="line">            alt_status = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scancode == caps_lock_make) &#123;</span><br><span class="line">            <span class="comment">/* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,</span></span><br><span class="line"><span class="comment">             * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/</span></span><br><span class="line">            caps_lock_status = !caps_lock_status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put_str(<span class="string">&quot;unknown key\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="105-环形输入缓冲区"><a class="markdownIt-Anchor" href="#105-环形输入缓冲区"></a> 10.5 环形输入缓冲区</h3>
<p>用来存储键盘输入结果，组成命令字符串传入其他模块使用。</p>
<h4 id="1051-生产者与消费者问题简述"><a class="markdownIt-Anchor" href="#1051-生产者与消费者问题简述"></a> 10.5.1 生产者与消费者问题简述</h4>
<p>略</p>
<h4 id="1052-环形缓冲区实现"><a class="markdownIt-Anchor" href="#1052-环形缓冲区实现"></a> 10.5.2 环形缓冲区实现</h4>
<p>内存中的缓冲区就是用来暂存数据的一片内存区域，内存是按地址来访问的，因此内存缓冲区实际上是线性存储。但是我们可以设计出逻辑上非线性的内存缓冲区，通过合理的操作方式可以构造出任何我们想要的数据结构，故这里引入环形缓冲区的概念。<br />
环形缓冲区本质上依然是线性缓冲区，但其使用方式像环一样，没有固定的起始地址和终止地址，环内任何地址都可以作为起始和结束。对于缓冲区访问这里提供两个指针，一个头指针，用于往缓冲区写数据，也可称为写指针；一个尾指针，用户往缓冲区读数据，也可称为读指针。<br />
<img src="https://cdn.nlark.com/yuque/0/2024/png/1249968/1704613691547-cd283140-8099-4233-8ff6-6295741742ca.png#averageHue=%23eeeeee&amp;clientId=u589813db-0770-4&amp;from=paste&amp;height=197&amp;id=u0ca96dc2&amp;originHeight=295&amp;originWidth=402&amp;originalType=binary%E2%88%B6=1.5&amp;rotation=0&amp;showTitle=false&amp;size=57331&amp;status=done&amp;style=none&amp;taskId=u25e844d0-c406-4da7-809d-e86bf72eed1&amp;title=&amp;width=268" alt="image.png" /><br />
我们在 device 目录下实现 ioqueue<br />
ioqueue.h：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DEVICE_IOQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEVICE_IOQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sync.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bufsize 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> &#123;</span></span><br><span class="line"><span class="comment">// 生产者消费者问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="comment">/* 生产者,缓冲区不满时就继续往里面放数据,</span></span><br><span class="line"><span class="comment">     * 否则就睡眠,此项记录哪个生产者在此缓冲区上睡眠。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">producer</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消费者,缓冲区不空时就继续从往里面拿数据,</span></span><br><span class="line"><span class="comment">     * 否则就睡眠,此项记录哪个消费者在此缓冲区上睡眠。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">consumer</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[bufsize];			    <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="type">int32_t</span> head;			    <span class="comment">// 队首,数据往队首处写入</span></span><br><span class="line">    <span class="type">int32_t</span> tail;			    <span class="comment">// 队尾,数据从队尾处读出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioqueue_init</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">ioq_full</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">ioq_empty</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">ioq_getchar</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioq_putchar</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq, <span class="type">char</span> byte)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里定义环形缓冲区有六个成员变量<br />
ioqueue.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ioqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化io队列ioq */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioqueue_init</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span> &#123;</span><br><span class="line">    lock_init(&amp;ioq-&gt;lock);     <span class="comment">// 初始化io队列的锁</span></span><br><span class="line">    ioq-&gt;producer = ioq-&gt;consumer = <span class="literal">NULL</span>;  <span class="comment">// 生产者和消费者置空</span></span><br><span class="line">    ioq-&gt;head = ioq-&gt;tail = <span class="number">0</span>; <span class="comment">// 队列的首尾指针指向缓冲区数组第0个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回pos在缓冲区中的下一个位置值 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">next_pos</span><span class="params">(<span class="type">int32_t</span> pos)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos + <span class="number">1</span>) % bufsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否已满 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ioq_full</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span> &#123;</span><br><span class="line">    ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line">    <span class="keyword">return</span> next_pos(ioq-&gt;head) == ioq-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否已空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ioq_empty</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span> &#123;</span><br><span class="line">    ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line">    <span class="keyword">return</span> ioq-&gt;head == ioq-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使当前生产者或消费者在此缓冲区上等待 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ioq_wait</span><span class="params">(<span class="keyword">struct</span> task_struct** waiter)</span> &#123;</span><br><span class="line">    ASSERT(*waiter == <span class="literal">NULL</span> &amp;&amp; waiter != <span class="literal">NULL</span>);</span><br><span class="line">    *waiter = running_thread();</span><br><span class="line">    thread_block(TASK_BLOCKED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒waiter */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="keyword">struct</span> task_struct** waiter)</span> &#123;</span><br><span class="line">    ASSERT(*waiter != <span class="literal">NULL</span>);</span><br><span class="line">    thread_unblock(*waiter);</span><br><span class="line">    *waiter = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消费者从ioq队列中获取一个字符 */</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">ioq_getchar</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq)</span> &#123;</span><br><span class="line">    ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若缓冲区(队列)为空,把消费者ioq-&gt;consumer记为当前线程自己,</span></span><br><span class="line"><span class="comment"> * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,</span></span><br><span class="line"><span class="comment"> * 也就是唤醒当前线程自己*/</span></span><br><span class="line">    <span class="keyword">while</span> (ioq_empty(ioq)) &#123;</span><br><span class="line">        lock_acquire(&amp;ioq-&gt;lock);</span><br><span class="line">        ioq_wait(&amp;ioq-&gt;consumer);</span><br><span class="line">        lock_release(&amp;ioq-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> byte = ioq-&gt;buf[ioq-&gt;tail];	  <span class="comment">// 从缓冲区中取出</span></span><br><span class="line">    ioq-&gt;tail = next_pos(ioq-&gt;tail);	  <span class="comment">// 把读游标移到下一位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioq-&gt;producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wakeup(&amp;ioq-&gt;producer);		  <span class="comment">// 唤醒生产者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生产者往ioq队列中写入一个字符byte */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioq_putchar</span><span class="params">(<span class="keyword">struct</span> ioqueue* ioq, <span class="type">char</span> byte)</span> &#123;</span><br><span class="line">    ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若缓冲区(队列)已经满了,把生产者ioq-&gt;producer记为自己,</span></span><br><span class="line"><span class="comment"> * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,</span></span><br><span class="line"><span class="comment"> * 也就是唤醒当前线程自己*/</span></span><br><span class="line">    <span class="keyword">while</span> (ioq_full(ioq)) &#123;</span><br><span class="line">        lock_acquire(&amp;ioq-&gt;lock);</span><br><span class="line">        ioq_wait(&amp;ioq-&gt;producer);</span><br><span class="line">        lock_release(&amp;ioq-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    ioq-&gt;buf[ioq-&gt;head] = byte;      <span class="comment">// 把字节放入缓冲区中</span></span><br><span class="line">    ioq-&gt;head = next_pos(ioq-&gt;head); <span class="comment">// 把写游标移到下一位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioq-&gt;consumer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wakeup(&amp;ioq-&gt;consumer);          <span class="comment">// 唤醒消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1053-添加键盘输入缓冲区"><a class="markdownIt-Anchor" href="#1053-添加键盘输入缓冲区"></a> 10.5.3 添加键盘输入缓冲区</h4>
<p>修改 keyboard.c 中<code>intr_keyboard_handler()</code>函数的 if(cur_char)语句内容：<br />
并且在<code>keyboard_init()</code>的 register_handler 前对 ioqueue 初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ioqueue.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> <span class="title">kbd_buf</span>;</span>	   <span class="comment">// 定义键盘缓冲区</span></span><br><span class="line">...</span><br><span class="line">ioqueue_init(&amp;kbd_buf);</span><br></pre></td></tr></table></figure>
<h4 id="1054-生产者与消费者测试"><a class="markdownIt-Anchor" href="#1054-生产者与消费者测试"></a> 10.5.4 生产者与消费者测试</h4>
<p>在 keyboard.h 中添加 kbd_buf 的外部声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> <span class="title">kbd_buf</span>;</span></span><br></pre></td></tr></table></figure>
<p>在 main.c 中添加消费者线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;I am kernel\n&quot;</span>);</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;consumer_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;A_ &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;consumer_b&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;B_ &quot;</span>);</span><br><span class="line"></span><br><span class="line">    intr_enable(); <span class="comment">// 打开中断, 使时钟中断起作用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程中运行的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 用void*来通用表示参数，被调用的函数知道自己需要什么类型的参数，自己转换再用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">        <span class="keyword">if</span> (!ioq_empty(&amp;kbd_buf)) &#123;</span><br><span class="line">            console_put_str(arg);</span><br><span class="line">            <span class="type">char</span> byte = ioq_getchar(&amp;kbd_buf);</span><br><span class="line">            console_put_char(byte);</span><br><span class="line">        &#125;</span><br><span class="line">        intr_set_status(old_status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，发现键盘每输入一个字符，线程 A 和 B 就会交替运行输出。</p>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
		
			<a href="/2023/10/30/yuque/roml7fefy7cyczd4/" title="《操作系统真象还原》：第九章 线程" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/10/30/yuque/roml7fefy7cyczd4/" title="《操作系统真象还原》：第九章 线程">
								《操作系统真象还原》：第九章 线程			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十月 30日, 2023				
							</p>
							<p class="relate-post-content">
								线程和进程将分两部分实现，本章先讲解线程。
 9.1 实现内核线程
 9.1.1 执行流
在处理器数量不变的情况下，多任务操作系统采用多道程序设计的方式，使处理器在所有任务之间来回切换，这称为“伪并行”，由操作系统中的任务调度器决定当...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/10/30/yuque/roml7fefy7cyczd4/" title="《操作系统真象还原》：第九章 线程">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第九章 线程"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/06/26/yuque/gflddumddhykfgqo/" title="GPU虚拟化">
								GPU虚拟化			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 26日, 2023				
							</p>
							<p class="relate-post-content">
								
 用户层虚拟化
 本地 API 拦截和 API formwarding


在用户态实现一个函数库，假设叫 libwrapper， 它要实现底层库的所有 API；
让 APP 调用这个 libwrapper。如何做？
libwrap...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/06/26/yuque/gflddumddhykfgqo/" title="GPU虚拟化">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="GPU虚拟化"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/06/23/yuque/tgft5m5mgh787k7d/" title="硬件虚拟化">
								硬件虚拟化			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 23日, 2023				
							</p>
							<p class="relate-post-content">
								 硬件虚拟化介绍
 硬件虚拟化要做的事情
 体系结构支持



体系结构
实现功能
作用




模式切换
Host CPU &lt;-&gt; Guest CPU 切换
CPU 资源隔离


二阶段地址转换
GVA-&gt; GPA...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/06/23/yuque/tgft5m5mgh787k7d/" title="硬件虚拟化">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="硬件虚拟化"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/01/20/yuque/dch1fprebtaxtqq8/" title="《操作系统真象还原》：第八章 内存管理系统">
								《操作系统真象还原》：第八章 内存管理系统			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 20日, 2023				
							</p>
							<p class="relate-post-content">
								 8.1 makefile 简介

这部分可参考阮一峰的讲解：https://www.ruanyifeng.com/blog/2015/02/make.html

 8.1.1 makefile 是什么
makefile 是 Linu...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/01/20/yuque/dch1fprebtaxtqq8/" title="《操作系统真象还原》：第八章 内存管理系统">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第八章 内存管理系统"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">
								《操作系统真象还原》：第七章 中断			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 25日, 2022				
							</p>
							<p class="relate-post-content">
								 7.1 中断是什么，为什么要有中断
运用中断能够显著提升并发，从而大幅提升效率。
 7.2 操作系统是中断驱动的
略
 7.3 中断分类
把中断按事件来源分类，来自 CPU 外部的中断就称为外部中断，来自 CPU 内部的中断称为内部...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第七章 中断"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">
								《操作系统真象还原》：第六章 完善内核			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 18日, 2022				
							</p>
							<p class="relate-post-content">
								 6.1 函数调用约定简介

咱们实验使用cdecl。这里提一下stdcall，cdecl与stdcall的区别在于由谁来回收栈空间。
stdcall是被调用者清理参数所占的栈空间。
举例来说：
12int subtract(int ...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第六章 完善内核"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" title="《操作系统真象还原》：第五章 保护模式进阶——加载内核">
								《操作系统真象还原》：第五章 保护模式进阶——加载内核			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 11日, 2022				
							</p>
							<p class="relate-post-content">
								 5.3 加载内核
 5.3.1 用 C 语言写内核
第一个 C 语言代码：
1234int main(void) &#123;	while(1);	return 0;&#125;
这个内核文件什么都没做，通过while(1)这个死循...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" title="《操作系统真象还原》：第五章 保护模式进阶——加载内核">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第五章 保护模式进阶——加载内核"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">
								《操作系统真象还原》：第五章 保护模式进阶——内存分页机制			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 19日, 2022				
							</p>
							<p class="relate-post-content">
								
从这一刻起，我们才算开始了真正的操作系统学习之旅

 5.1 获取物理内存容量
 5.1.1 Linux 获取内存的方法
在 Linux 2.6 内核总是用detect_memory函数来获取内存容量的。其函数子啊本质上是通过调用 ...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">
								《操作系统真象还原》：第四章 保护模式入门			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 8日, 2022				
							</p>
							<p class="relate-post-content">
								 4.1 保护模式概述
在本章大家会见到全局描述符表、中断描述符表、各种门结构，这是 CPU 提供给应用的，咱们用好就行。
保护模式强调的是“保护”，它是在 Intel 80286 CPU 中首次出现，这是继 8086 之后，Inte...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第四章 保护模式入门"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">
								《操作系统真象还原》：第三章 完善MBR——I/O接口			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 25日, 2022				
							</p>
							<p class="relate-post-content">
								 3.3 让我们对显示器说点什么吧
 3.3.1 CPU 如何与外设通信——IO 接口
IO 接口功能：

设置数据缓冲，解决 CPU 与外设的速度不匹配
设置信号电平转换电路
设置数据格式转换
设置时序控制电路来同步 CPU 和外部...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="《操作系统真象还原》：第三章 完善MBR——I/O接口"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	

		

			<!-- gitalk comment -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">

	(function gitalkComment(){
		//Thanks O-R
		//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
		//去除尾部匹配正则数组的字符串  
		//Remove redundant characters
		String.prototype.trimEnd = function(regStr) {
			let result = this;
			if(regStr == undefined || regStr == null || regStr == "") {
				return result;
			}
			let array = regStr.split(',');

			if(array.length > 0) {

				let c = array.shift(), 
					str = this,
					i = str.length,
					rg = new RegExp(c),
					matchArr = str.match(rg);

				if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
					let matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
						.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
						.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
						.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
						.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
						.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
						.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
						.replace(/\./g, "\\.").replace(/\&/g, "\\&");
					matchStr = matchStr + '$';
					result = str.replace(new RegExp(matchStr), "");
				}

				if(array.length > 0) {
					return result.trimEnd(array.join())
				} else {
					return result;
				}
			}
		};

		//Create gitalk
		let gitalk = new Gitalk({
			clientID: '693063c1941dbc1701d3',
			clientSecret: 'f88ddf502ef33ce91ce9d8c140dbc7e3a0653b7e',
			//id: window.location.pathname,
			//id: decodeURI(window.location.pathname),
			//id: (window.location.pathname).split("/").pop().substring(0, 49),
			id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
			repo: 'lisongqian.github.io',
			owner: 'lisongqian',
			admin: 'lisongqian',
			distractionFreeMode: 'false',
		})
		gitalk.render('gitalk-container');		
	})();
</script>

		
		
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>

	<div class="copyright">
		<p>
		<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">鲁ICP备16042410号</a>
			 
				&copy;2017 - 2024, content by SongqianLi. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		

<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>




<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  

	<!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup scrollbar" >
	<div class="local-search-container">
		<span class="popup-btn-close">
      		ESC
   		</span>
		<div class="local-search-header">
			<div class="input-prompt">				
			</div>
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			<div class="topN-post">				
				
								
			</div>
		</div>
	</div>
</div>


<script src="/plugin/search/ziploader.js"></script>
<script src="/js/search.js"></script>


<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>