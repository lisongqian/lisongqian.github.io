---
layout: article
tags: BigData
description: Pregel是一种基于BSP模型实现的并行图处理系统
---

## I.引言

### 简介

> Pregel是一种基于BSP模型实现的并行图处理系统
> <!--more-->
> > 为了解决大型图的分布式计算问题，Pregel搭建了一套可扩展的、有容错机制的平台，该平台提供了一套非常灵活的API，可以描述各种各样的图计算
> >
> > Pregel作为分布式图计算的计算框架，主要用于图遍历、最短路径、PageRank计算等等



## II.开始

### 1、有向图顶点

![paste image](http://cdn.lisongqian.cn/1517450859206rohzv82s.png?imageslim)

Pregel计算模型以有向图作为输入

有向图的每个顶点都有一个String类型的顶点ID

每个顶点都有一个可修改的用户自定义值与之关联

每条有向边都和其源顶点关联，并记录了其目标顶点ID

边上有一个可修改的用户自定义值与之关联

### 2、超步

所谓超步就是计算中的一次迭代，每个超步主要包括三个组件：

```
局部计算：每个参与的处理器都有自身的计算任务
通讯：处理器群相互交换数据
栅栏同步(Barrier Synchronization)：当一个处理器遇到“路障”（或栅栏），会等到其他所有处理器完成它们的计算步骤 
```

![paste image](http://cdn.lisongqian.cn/1517454632223wlkyf87n.png?imageslim)

![paste image](http://cdn.lisongqian.cn/15174512744729aoifhmy.png?imageslim)

在每个超步S中，图中的所有顶点都会并行执行相同的用户自定义函数

每个顶点可以接收前一个超步(S-1)中发送给它的消息，修改其自身及其出射边的状态，并发送消息给其他顶点，甚至是修改整个图的拓扑结构

在这种计算模式中，“边”并不是核心对象，在边上面不会运行相应的计算，只有**顶点**才会执行用户自定义函数进行相应计算

### 3、传递消息方法

消息传递的基本方法有`远程读取`和`基于共享内存`。
但是Pregel采用的方法是`消息传递模型`

![paste image](http://cdn.lisongqian.cn/1517451712272diwp53ir.png?imageslim)

因为：

```
（1）消息传递具有足够的表达能力，没有必要使用远程读取或共享内存的方式
（2）有助于提升系统整体性能
```

### 4、计算过程

在每个超步中，每个顶点上面都会并行执行用户自定义的函数，该函数描述了一个顶点V在一个超步S中需要执行的操作该函数可以读取前一个超步(S-1)中其他顶点发送给顶点V的消息，执行相应计算后，修改顶点V及其出射边的状态，然后沿着顶点V的出射边发送消息给其他顶点，而且，一个消息可能经过多条边的传递后被发送到任意已知ID的目标顶点上去这些消息将会在下一个超步(S+1)中被目标顶点接收，然后象上述过程一样开始下一个超步(S+1)的迭代过程在第0个超步，所有顶点处于活跃状态当一个顶点不需要继续执行进一步的计算时，就会把自己的状态设置为“停机”，进入非活跃状态

**计算实例：（求最大值）**

![paste image](http://cdn.lisongqian.cn/1517452349809brmsw5n8.png?imageslim)

超步0：不需计算，各个顶点将自身的值通过出射边向外发送。即：

```
A将3发送给B
B将6发送给A和D
C将2发送给B和D
D将1发送给C
```

超步1：首先读取上一超步中发送过来的消息队列，经过自定义函数计算后，如果值发生变化，则顶点保持活跃状态；不变，则顶点变为非活跃状态。即：

```
A读取队列消息6，自定义函数为比较函数，3<6，所以A的值变为6，A保持活跃，并将当前值向外发送。
B读取队列消息3,6>3，值不变；读取队列消息2,6>2，值不变，B进入停机状态。
C读取队列消息1,2>1，值不变，进入停机状态。
D读取队列消息6,1<6，值改变为6;读取队列消息2,6>2，值不变，B保持活跃状态，并将当前值向外发送。
```

超步2：迭代执行超步1。即：

```
A读取消息队列为空，A的值不发生改变，A进入停机状态。
B读取消息队列6,6=6，B的值不发生改变，B保持停机状态。
C读取消息队列6,2<6,C的值变为6，C被激活，变为活跃状态。
D读取消息队列为空，的值不发生改变，D进入停机状态。
```

超步3：迭代执行超步1。即：

```
A读取消息队列为空，A保持停机状态。
B读取消息队列6,6=6，B的值不发生改变，B保持停机状态。
C读取消息队列为空，C进入停机状态。
D读取消息队列6,6=6，D的值不发生改变，D保持停机状态。
```

**此时A,B,C,D全部进入非活跃状态，且无消息发出，此时算法顺利结束，求得最大值为6。**