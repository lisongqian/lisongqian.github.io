<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      《操作系统真象还原》：第五章 保护模式进阶——加载内核 | Songqian Li&#39;s Blog
    
  </title>
  <meta name="author" content="Songqian Li">
  <meta name="keywords" content="" />
  <meta name="description" content="C U" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900">
  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: 'https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: false
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: true,
	  appId: 'L0W62cCkHAgT0VsIX6WztMhp-gzGzoHsz',
	  appKey: 'n1lX9eWfotXltQ6Cab3ngGfk',
	  serverURLs: 'https://l0w62cck.lc-cn-n1-shared.com' || ' '
    }
  </script>
  <!-- site analysis -->
  

	<!-- site-analysis -->
	
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "//hm.baidu.com/hm.js?b702b9b0aa72233c214dcbade17a5a27";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>

	
	
	
	
 
    <meta name="referrer" content="no-referrer"/>
<meta name="generator" content="Hexo 6.3.0"></head>
	<body>
		<!-- Preloader -->


<!-- header -->
<header class="fixbackground">
		<div class="header-wrapper">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	<div class="mask">
	<div class="banner-frame border-image" style="border-image-source: url('https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/mask.png');"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-12">
					<div class="align">
						<h1 class="h1 light">Songqian Li&#39;s Blog</h1>
						<div class="empty-space col-xs-b15"></div>
						<div class="sa light large">C U</div>
						<div class="empty-space col-xs-b30"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- motto -->
		<div class="h-body">	
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「《操作系统真象还原》：第五章 保护模式进阶——加载内核」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<!--<span class="logo"> 
			<img src="/img/logo.png">
		</span> -->
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="//github.com/lisongqian" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" itemprop="url">
		《操作系统真象还原》：第五章 保护模式进阶——加载内核
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2022/12/11/yuque/mguvy5fxrt54cg9m/" itemprop="url">
		<time datetime="2022-12-11T12:03:26.000Z" itemprop="dateUpdated">
	  		2023-01-20
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/OS/" class=" ">
			OS
		</a>
	
		<a href="/tags/Reading/" class=" ">
			Reading
		</a>
	
		
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<h2 id="5-3-加载内核"><a href="#5-3-加载内核" class="headerlink" title="5.3 加载内核"></a>5.3 加载内核</h2><h4 id="5-3-1-用-C-语言写内核"><a href="#5-3-1-用-C-语言写内核" class="headerlink" title="5.3.1 用 C 语言写内核"></a>5.3.1 用 C 语言写内核</h4><p>第一个 C 语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个内核文件什么都没做，通过<code>while(1)</code>这个死循环一直使用 CPU，目的是停在这里。这个死循环仅仅是为了演示 elf 文件解析以及加载内核的作用。<br>用 gcc 编译该程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c -o kernel/main.o kernel/main.c</span><br></pre></td></tr></table></figure>

<p><code>-c</code>的作用是编译、汇编到目标代码，不进行链接，也就是直接生成目标文件。<br><code>-o</code>的作用是将输出的文件以指定文件名来存储，有同名文件存在时直接覆盖。<br><code>main.o</code>文件还是个“半成品”，因为它只是个目标文件，也称为待重定位文件，重定位指的是文件里面所用的符号还没有安排地址，这些符号的地址需要将来与其他目标文件“组成”一个可执行文件时再重新定位（编排地址）。这里的符号就是指该目标文件中所调用的函数或使用的变量，这里的“组成”就是指链接。由于不知道可执行文件由几个目标文件组成，所以一律在链接阶段对符号重新定位（编排地址）。<br>用<code>file kernel/main.o</code>来检查一下文件状态，可以看到目标文件是有<code>relocatable</code>属性的：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668771672668-6dfbce2b-ed57-44aa-88da-e602d15c8df8.png#averageHue=%23300b27&clientId=ufe5f1442-fc98-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=26&id=ue5a32764&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=734&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13779&status=done&style=none&taskId=u9ac3ad8a-e6bc-40d0-9012-f71066d7511&title=&width=489.3333333333333" alt="image.png"><br>用<code>nm kernel/main.o</code>列出符号信息，发现由于 main 函数地址未被链接，所以其值为<code>00000000</code>：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668771803511-8936a2c2-c133-4320-aa42-6636b2041fe6.png#averageHue=%23300a25&clientId=ufe5f1442-fc98-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=26&id=u6d2333b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=497&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=7891&status=done&style=none&taskId=u9ca84ede-28e8-43dd-b886-ae794e6f658&title=&width=331.3333333333333" alt="image.png"><br>在 Linux 下用 ld 链接程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin</span><br></pre></td></tr></table></figure>

<p><code>-Ttext</code>指定起始虚拟地址为<code>0xc0001500</code>，这个地址是设计好的；<br><code>-o</code>指定输出的文件；<br><code>-e</code>指定程序的入口地址，参数可以是数字形式的地址，也可以是符号名。默认入口地址是<code>_start</code>；<br>我们用 gcc 直接生成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -o kernel/test.bin kernel/main.c</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668772835470-93f892ef-5184-4672-8800-212d3ac28055.png#averageHue=%23300b27&clientId=ufe5f1442-fc98-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=51&id=ud8e4ae59&margin=%5Bobject%20Object%5D&name=image.png&originHeight=77&originWidth=651&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=25660&status=done&style=none&taskId=u94040295-c908-47c2-ac43-2c3cdb3f580&title=&width=434" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668772667156-3da01317-a4e7-4fd9-8463-1f9a76bac158.png#averageHue=%23300a25&clientId=ufe5f1442-fc98-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=47&id=u109af3ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=70&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15642&status=done&style=none&taskId=u7948cfe9-2975-4fd3-9380-9dadfca46c6&title=&width=413.3333333333333" alt="image.png"><br>可以发现直接编译生成的文件比手动链接生成的文件大得多，在 test.bin 中出现了很多不是咱们代码中存在的符号，说明编译器在编译过程中为咱们引用了别的代码，这就是 C 运行库的功劳，目的是在调用 main 函数前做初始化环境等工作。<br>其实这段 C 语言代码换成汇编代码的话就是个<code>jmp $</code>，其大小不过是 2 字节的机器码<code>ebfe</code>。除了编译器自动添加的代码外，一般情况下 C 语言编译出来的程序也比汇编语言生成的程序体积大。可见人们常说的汇编语言比 C 语言快，并不是汇编语言本身有多快（它也要变成机器指令后才能上 CPU 运行），而是汇编语言对应的机器指令是一对一的、简单、直接、可依赖，而 C 语言生成的机器指令是一对多的、复杂、间接、略冗余。</p>
<h4 id="5-3-2-二进制程序的运行方法"><a href="#5-3-2-二进制程序的运行方法" class="headerlink" title="5.3.2 二进制程序的运行方法"></a>5.3.2 二进制程序的运行方法</h4><p>BIOS 调用 MBR，MBR 的地址是<code>0x7c00</code>，MBR 调用 loader，loader 的地址是<code>0x900</code>，这两个地址是固定的，也就是说我们目前的方法是很不灵活的，调用方需要提前和被调用方约定调用地址。<br>在程序中，程序头（也就是文件头〉用来描述程序的布局等信息，它属于信息的信息，也就是元数据。包含程序头的程序文件示意如图 5-32 所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668845239931-a312d95b-a336-4698-80b5-654ed40d80ef.png#averageHue=%23e4e4e4&clientId=u70283783-141e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=u765081c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=395&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=100133&status=done&style=none&taskId=u5bccf994-d957-427c-b12c-8cb00e2ee8f&title=&width=263.3333333333333" alt="image.png"><br>以 header.S 为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">header:</span><br><span class="line">	program_length	<span class="built_in">dd</span>	program_end-program_start</span><br><span class="line">	start_addr	<span class="built_in">dd</span>	program_start</span><br><span class="line">;;;;;		以上文件头，以下文件体		;;;;;</span><br><span class="line">body:</span><br><span class="line">program_start:</span><br><span class="line">	mov ax, 0x1234</span><br><span class="line">	jmp $</span><br><span class="line">program_end:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用方程序知道 header.S 的文件格式，于是：</p>
<ol>
<li>将 header.bin 前 8 字节的内容读到内存，前 4 字节是程序体长度，后 4 字节是程序的入口地址；</li>
<li>将 header.bin 开头偏移 8 字节的地方作为起始，将 header.bin 文件尾即开头偏移（8+程序体长度）个字节的地方作为终止；</li>
<li>将起始至终止之间的程序体复制到入口地址；</li>
<li>转到入口地址处执行。</li>
</ol>
<h4 id="5-3-3-elf-格式的二进制文件"><a href="#5-3-3-elf-格式的二进制文件" class="headerlink" title="5.3.3 elf 格式的二进制文件"></a>5.3.3 elf 格式的二进制文件</h4><p>Windows 下的可执行文件格式是 PE，即 Protable Executable，Linux 下可执行文件格式是 ELF，即 Executable and Linkable Format，可执行链接格式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668846848844-6966dbc0-be60-4e98-a4b0-0165d80c90dc.png#averageHue=%23dcdcdc&clientId=ub3833c64-e540-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=uf95f52ee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=1488&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=563831&status=done&style=none&taskId=uc8f205d4-9163-4d2a-8bc5-e92dcd8d34a&title=&width=992" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668847308064-d9b437e8-1149-4b7c-ad35-e837afdc0ef2.png#averageHue=%23e5e5e5&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=385&id=ud52e3c20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=729&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=221614&status=done&style=none&taskId=u72d7288d-bc91-4c07-91dc-b03b215edb1&title=&width=486" alt="image.png"></p>
<h5 id="ELF-Header-数据结构"><a href="#ELF-Header-数据结构" class="headerlink" title="ELF Header 数据结构"></a>ELF Header 数据结构</h5><p>有关 elf 的任何定义，包括变量、常量及取值范围，都可以在 Linux 系统的<code>/usr/include/elf.h</code>中找到。<br><a target="_blank" rel="noopener" href="https://llvm.org/doxygen/BinaryFormat_2ELF_8h_source.html">https://llvm.org/doxygen/BinaryFormat_2ELF_8h_source.html</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668847426814-3f5284ab-efa4-4428-82c4-e873e76a94e5.png#averageHue=%23e7e7e7&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=ua47a91df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=329&originWidth=1533&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=181152&status=done&style=none&taskId=u85756ccf-ba77-4bbe-be9d-a467f0c506d&title=&width=1022" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">// ELF Identification bytes</span></span><br><span class="line">  Elf32_Half e_type;                <span class="comment">// Type of file (see ET_* below)</span></span><br><span class="line">  Elf32_Half e_machine;   <span class="comment">// Required architecture for this file (see EM_*)</span></span><br><span class="line">  Elf32_Word e_version;   <span class="comment">// Must be equal to 1</span></span><br><span class="line">  Elf32_Addr e_entry;     <span class="comment">// Address to jump to in order to start program</span></span><br><span class="line">  Elf32_Off e_phoff;      <span class="comment">// Program header table&#x27;s file offset, in bytes</span></span><br><span class="line">  Elf32_Off e_shoff;      <span class="comment">// Section header table&#x27;s file offset, in bytes</span></span><br><span class="line">  Elf32_Word e_flags;     <span class="comment">// Processor-specific flags</span></span><br><span class="line">  Elf32_Half e_ehsize;    <span class="comment">// Size of ELF header, in bytes</span></span><br><span class="line">  Elf32_Half e_phentsize; <span class="comment">// Size of an entry in the program header table</span></span><br><span class="line">  Elf32_Half e_phnum;     <span class="comment">// Number of entries in the program header table</span></span><br><span class="line">  Elf32_Half e_shentsize; <span class="comment">// Size of an entry in the section header table</span></span><br><span class="line">  Elf32_Half e_shnum;     <span class="comment">// Number of entries in the section header table</span></span><br><span class="line">  Elf32_Half e_shstrndx;  <span class="comment">// Sect hdr table index of sect name string table</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">checkMagic</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">memcmp</span>(e_ident, ElfMagic, <span class="built_in">strlen</span>(ElfMagic))) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">getFileClass</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> e_ident[EI_CLASS]; &#125;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">getDataEncoding</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> e_ident[EI_DATA]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先介绍 elf 的结构：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>e_ident[16]</code></td>
<td>16 字节的数组，用来表示 elf 字符等信息，开头的 4 个字节是固定不变的，是 elf 文件的魔数，它们分别是<code>0x7f</code>、字符串 ELF 的 asc 码：<code>0x45</code>、<code>0x4c</code>、<code>0x46</code>。详见表 5-9</td>
</tr>
<tr>
<td><code>e_type</code></td>
<td>用来指定 elf 目标文件的类型，详见表 5-10，后两种是与硬件相关的参数，故取值很“怪异”</td>
</tr>
<tr>
<td><code>e_machine</code></td>
<td>用来描述 elf 目标文件的体系结构类型，也就是说该文件要在哪种硬件平台（哪种机器）上才能运行，详见表 5-11</td>
</tr>
<tr>
<td><code>e_version</code></td>
<td>用来表示版本信息</td>
</tr>
<tr>
<td><code>e_entry</code></td>
<td>用来指明操作系统运行该程序时，将控制权转交到的虚拟地址</td>
</tr>
<tr>
<td><code>e_phoff</code></td>
<td>用来指明程序头表（program header table）在文件内的字节偏移量。如果没有程序头表，该值为 0</td>
</tr>
<tr>
<td><code>e_shoff</code></td>
<td>用来指明节头表（section header table）在文件内的字节偏移量。若没有节头表，该值为 0</td>
</tr>
<tr>
<td><code>e_flags</code></td>
<td>用来指明与处理器相关的标志</td>
</tr>
<tr>
<td><code>e_ehsize</code></td>
<td>用来指明 elfheader 的宇节大小</td>
</tr>
<tr>
<td><code>e_phentsize</code></td>
<td>用来指明程序头表（program header table）中每个条目（entry ）的字节大小，即每个用来描述段信息的数据结构的字节大小</td>
</tr>
<tr>
<td><code>e_phnum</code></td>
<td>用来指明程序头表中条目的数量，实际就是段的个数</td>
</tr>
<tr>
<td><code>e_shentsize</code></td>
<td>用来指明节头表（section header table）中每个条目（entry）的字节大小，即 每个用来描述节信息的数据结构的字节大小</td>
</tr>
<tr>
<td><code>shnum</code></td>
<td>用来指明节头表中条目的数量。实际上就是节的个数</td>
</tr>
<tr>
<td><code>e_shstrndx</code></td>
<td>用来指明 string name table 在节头表中的索引 index</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668847653660-a730502d-c797-48a7-be54-97a15b26a8bf.png#averageHue=%23ececec&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=503&id=u352dd3c0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=754&originWidth=1425&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=433693&status=done&style=none&taskId=u057e1941-f250-4969-90d7-bb954f488ee&title=&width=950" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668848065073-4b1c26b8-c6b5-40f9-9624-b546810e50c1.png#averageHue=%23e8e8e8&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=128&id=u2ccf28b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=1402&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88831&status=done&style=none&taskId=u343e5fda-d371-4d20-8817-4c077496015&title=&width=934.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668848077109-4e5b48cd-fff7-46b7-a57d-946d4c0afc2a.png#averageHue=%23dfdfdf&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=145&id=u67feaf1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=1406&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=159446&status=done&style=none&taskId=u42a79b94-8446-40e9-b959-7c49956d9bb&title=&width=937.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668848241128-4cc7b217-c5d5-46a0-b1af-4a3fe6469f9b.png#averageHue=%23eaeaea&clientId=u8191686b-4995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=ud8fcd4d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=1408&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=211682&status=done&style=none&taskId=udee467cb-caea-4cd2-9016-f9671486333&title=&width=938.6666666666666" alt="image.png"></p>
<h5 id="程序头表的数据结构"><a href="#程序头表的数据结构" class="headerlink" title="程序头表的数据结构"></a>程序头表的数据结构</h5><p><code>struct Elf32_Phdr</code>结构的功能类似 GDT 中段描述符的作用，段描述符用来描述物理内存中的一个内存段，而<code>struct Elf32 Phdr</code>是用来描述位于磁盘上的程序中的一个段，它被加载到内存后才属于 GDT 中段描述符所指向的内存段的子集。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program header for ELF32.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> &#123;</span></span><br><span class="line">  Elf32_Word p_type;   <span class="comment">// Type of segment</span></span><br><span class="line">  Elf32_Off p_offset;  <span class="comment">// File offset where segment is located, in bytes</span></span><br><span class="line">  Elf32_Addr p_vaddr;  <span class="comment">// Virtual address of beginning of segment</span></span><br><span class="line">  Elf32_Addr p_paddr;  <span class="comment">// Physical address of beginning of segment (OS-specific)</span></span><br><span class="line">  Elf32_Word p_filesz; <span class="comment">// Num. of bytes in file image of segment (may be zero)</span></span><br><span class="line">  Elf32_Word p_memsz;  <span class="comment">// Num. of bytes in mem image of segment (may be zero)</span></span><br><span class="line">  Elf32_Word p_flags;  <span class="comment">// Segment flags</span></span><br><span class="line">  Elf32_Word p_align;  <span class="comment">// Segment alignment constraint</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>p_type</code></td>
<td>用来指明程序中该段的类型，详见表 5-12</td>
</tr>
<tr>
<td><code>p_offset</code></td>
<td>用来指明本段在文件内的起始偏移字节</td>
</tr>
<tr>
<td><code>p_vaddr</code></td>
<td>用来指明本段在文件内的起始偏移字节</td>
</tr>
<tr>
<td><code>p_paddr</code></td>
<td>用来指明本段在内存中的起始虚拟地址</td>
</tr>
<tr>
<td><code>p_filesz</code></td>
<td>用来指明本段在文件中的大小</td>
</tr>
<tr>
<td><code>p_memsz</code></td>
<td>用来指明本段在内存中的大小</td>
</tr>
<tr>
<td><code>p_flags</code></td>
<td>用来指明与本段相关的标志，详见表 5-13</td>
</tr>
<tr>
<td><code>p_align</code></td>
<td>用来指明本段在文件和内存中的对齐方式；如果值为 0 或 1 ，则表示不对齐。否则应该是 2 的幂次数；</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668849059710-0edf7475-8ef8-4adf-994d-24e42dec24ca.png#averageHue=%23e6e6e6&clientId=u972f7b72-3cd5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=uae0476f9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=503&originWidth=1482&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=268607&status=done&style=none&taskId=ue86ca2bf-bc55-4a7c-bba9-4effc545121&title=&width=988" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1668849170249-7a7bc386-d040-4892-8804-90cd2df80343.png#averageHue=%23e8e8e8&clientId=u972f7b72-3cd5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u533da022&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=1490&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=186844&status=done&style=none&taskId=uc7358f24-7477-4f49-a765-6dad32c4ae5&title=&width=993.3333333333334" alt="image.png"></p>
<h4 id="5-3-4-elf-文件实例分析"><a href="#5-3-4-elf-文件实例分析" class="headerlink" title="5.3.4 elf 文件实例分析"></a>5.3.4 elf 文件实例分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -u a -g I -s <span class="variable">$2</span> -l <span class="variable">$3</span> <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>使用<code>./xxd.sh kernel/kernel.bin 0 300</code>分析 kernel.bin：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669022798435-ce91291e-f1b9-4467-9a20-b3c2259e6229.png#averageHue=%23300b27&clientId=u2a18f936-b307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u37b79dc4&margin=%5Bobject%20Object%5D&name=sp20221121_170909_415.png&originHeight=364&originWidth=681&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=51221&status=done&style=none&taskId=u6b5bb0c6-6fc9-48a6-a594-16ba1b67a39&title=" alt="sp20221121_170909_415.png"><br>脚本的输出大概分了三部分：</p>
<ol>
<li>最左边的一列是十六进制的地址，或者称为偏移量最为恰当。</li>
<li>中间这一大块矩阵似的十六进制数字是文件中的内容，每两位十六进制数字为一字节，每行共 16 个字节。</li>
<li>最右边那一列，含有点点的、偶尔伴有可读字符的部分是字符显示区，这部分将内容按照字符编码显示，不是可显示的字符便显示为“.”。</li>
</ol>
<p>中间部分：</p>
<ol>
<li><p>elf header 部分：</p>
<table>
<thead>
<tr>
<th><strong>行数</strong></th>
<th><strong>占位(单位：字节)</strong></th>
<th><strong>HEX</strong></th>
<th><strong>属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>16</td>
<td>7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00</td>
<td>e_indent 数组</td>
<td><code>7F 45 4C 46</code>为魔数，<code>01</code>代表 32 位 elf 文件，<code>01</code>小端字节序，<code>01</code>当前版本</td>
</tr>
<tr>
<td>第二行</td>
<td>2</td>
<td>02 00</td>
<td>e_type</td>
<td>值为<code>0x02</code>，类型为<code>ET_EXEC</code>可执行文件</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>01 00</td>
<td>e_machine</td>
<td>值为 1,表示为<code>EM_386</code></td>
</tr>
<tr>
<td></td>
<td>4</td>
<td>01 00 00 00</td>
<td>e_version</td>
<td>版本信息</td>
</tr>
<tr>
<td></td>
<td>4</td>
<td>00 15 00 C0</td>
<td>e_entry</td>
<td>值为<code>0xc0001500</code>，程序的虚拟入口地址</td>
</tr>
<tr>
<td></td>
<td>4</td>
<td>34 00 00 00</td>
<td>e_phoff</td>
<td>值为<code>0x34</code>，表示程序头表在文件中的偏移量</td>
</tr>
<tr>
<td>第三行</td>
<td>4</td>
<td>BC 21 00 00</td>
<td>e_shoff</td>
<td>值为<code>0x21BC</code>，表示节头表在文件中的偏移量</td>
</tr>
<tr>
<td></td>
<td>4</td>
<td>00 00 00 00</td>
<td>e_flags</td>
<td>指明与处理器相关的标志</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>34 00</td>
<td>e_ehsize</td>
<td>值为<code>0x34</code>,表示 elf header 大小（这与 e_phoff 大小一致，说明程序头表紧跟 elf header 后）</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>20 00</td>
<td>e_phentsize</td>
<td>值为<code>0x20</code>，32 字节，即<code>struct Elf64_Phdr</code>的大小</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>07 00</td>
<td>e_phnum</td>
<td>值为 7，表示程序头表中有 7 个段</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>28 00</td>
<td>e_shentsize</td>
<td>值为<code>0x28</code>，表示节头表中节的大小</td>
</tr>
<tr>
<td>第四行</td>
<td>2</td>
<td>09 00</td>
<td>e_shnum</td>
<td>值为 9，表示有 9 个节</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>08 00</td>
<td>e_shstrndx</td>
<td>值为 7，表示<code>string name table</code>在节头中的索引为 8</td>
</tr>
</tbody></table>
</li>
<li><p>program header 部分：<br>| <strong>行数</strong> | <strong>占位</strong><br><strong>单位：字节</strong> | <strong>HEX</strong> | <strong>属性</strong> | <strong>含义</strong> |<br>| — | — | — | — | — |<br>| 第四行 | 4 | 01 00 00 00 | p_type | 值为 1，指明程序中该段的类型为<code>可加载程序段</code> |<br>| | 4 | 00 00 00 00 | p_offset | 值为 0，表示本段在文件内的偏移量（存疑） |<br>| | 4 | 00 80 04 08 | p_vaddr | 值为<code>0x08048000</code>，表示本段被加载到内存后的起始虚拟地址 |<br>| 第五行 | 4 | 00 80 04 08 | p_paddr | 它通常和 p_vaddr 值一致，但该属性是保留项 |<br>| | 4 | 30 01 00 00 | p_filesz | 值为<code>0x0130</code>，304 字节，表示本段在文件中的字节大小 |<br>| | 4 | 30 01 00 00 | p_memsz | 值为<code>0x0130</code>，表示本段在内存中的大小，由于段无论在哪里，逻辑大小是不变的，故该值等于<code>p_filesz</code> |<br>| | 4 | 04 00 00 00 | p_flags | 值为 4，表示<code>PF_R</code>，为可读 |<br>| 第六行 | 4 | 00 10 00 00 | p_align | 值为<code>0x1000</code>，4096，表示本段对齐的方式 |</p>
</li>
</ol>
<p>使用<code>readelf -e kernel/kernel.bin</code>查看信息：<br>-e 相当于 -hls<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669023320325-33b4ced7-4b1c-4ffc-b328-3a18dbb78447.png#averageHue=%23300a25&clientId=u2a18f936-b307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=697&id=uf8813b65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1046&originWidth=736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=182236&status=done&style=none&taskId=ub3ee51ca-edad-48c6-a93a-28bfa3e0c9b&title=&width=490.6666666666667" alt="image.png"></p>
<h4 id="5-3-5-将内核载入内存"><a href="#5-3-5-将内核载入内存" class="headerlink" title="5.3.5 将内核载入内存"></a>5.3.5 将内核载入内存</h4><p>回顾一下计算机启动过程：</p>
<ol>
<li>计算机启动后，运行的第一个程序是 BIOS，BIOS 检查、初始化硬件之后，将 0 盘 0 柱面 1 扇区的 MBR 加载到内存 0x7C00 的位置并跳转过去；</li>
<li>MBR 选择指定的操作系统的内核加载器程序 loader，从硬盘中读取出 loader 程序到内存中并跳转过去；</li>
<li>loader 将内核 kernel 程序从硬盘上读出并加载到内存中。</li>
</ol>
<p>目前为止硬盘使用情况：</p>
<table>
<thead>
<tr>
<th><strong>扇区</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>第 0 扇区</td>
<td>MBR</td>
</tr>
<tr>
<td>第 1 扇区</td>
<td>空</td>
</tr>
<tr>
<td>第 2 扇区</td>
<td>loader，由于 loader.bin 目前的大小是 1342 字节，占用 3 个扇区</td>
</tr>
<tr>
<td>第 3 扇区</td>
<td>loader</td>
</tr>
<tr>
<td>第 4 扇区</td>
<td>loader</td>
</tr>
<tr>
<td>第 5 扇区</td>
<td>空</td>
</tr>
</tbody></table>
<p>内存使用情况：</p>
<table>
<thead>
<tr>
<th><strong>内存范围</strong></th>
<th><strong>大小</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0x000~0x3FF</td>
<td>1k</td>
<td>IVT，中断向量表</td>
</tr>
<tr>
<td>0x400~0x4FF</td>
<td>256B</td>
<td>BIOS</td>
</tr>
<tr>
<td>0x500~0x7BFF</td>
<td>30K</td>
<td>可用</td>
</tr>
<tr>
<td>0x7C00~0x7DFF</td>
<td>512B</td>
<td>MBR</td>
</tr>
<tr>
<td>0x7E00~0x9FBFF</td>
<td>608K</td>
<td>可用</td>
</tr>
<tr>
<td>0x9FC00~0x9FFFF</td>
<td>1k</td>
<td>EBDA(Extended BIOS Data Area)扩展 bios 数据区</td>
</tr>
</tbody></table>
<p>我们将 kernel 写入硬盘的第 9 扇区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot/kernel.bin of=hd60M.img bs=512 count=200 seek=9 conv=notrunc</span><br></pre></td></tr></table></figure>

<p>我们将来的内核大小不会超过 100KB，所以直接把 count 改为 200 扇区。而且 dd 命令会自己判断写入的数据量，如果参数 if 指定的文件大小小于 count*bs，只按照实际文件大小写入。<br>内核是由 loader 加载的，loader 需要完成：</p>
<ol>
<li><strong>加载内核</strong>：需要把内核文件加载到内存缓冲区</li>
</ol>
<p>程序执行到 loader 后，MBR 的使命就结束了，所以 MBR 占用的内存区可以被覆盖掉了。<br>内核被加载到内存后，loader 还要通过分析其 elf 结构将其展开到新的位置，内核在内存中有两份拷贝，一份是 elf 格式的原文件，另一份是 loader 解析 elf 格式的 kernel.bin 后在内存中生成的内核映像（也就是将程序中的各种段 segment 复制到内存后的程序体），这个映像才是真正运行的内核。<br>我们可以将内核文件 kernel.bin 加载到地址较高的空间，而内核映像要放置到较低的地址。内核文件经过 loader 解析后就没用了，这样内核印象将来往搞地质处扩展时可以覆盖原来的内核文件 kernel.bin。<br>这里我们选的 kernel 地址为<code>0x70000</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;----加载 kernel----</span><br><span class="line">mov eax, KERNEL_START_SECTOR    ;kernel.bin所在的扇区号</span><br><span class="line">mov ebx, KERNEL_BIN_BASE_ADDR   ;从硬盘读出后写入的地址</span><br><span class="line">mov ecx, 200                    ;读入的扇区数</span><br><span class="line"></span><br><span class="line">call rd_disk_m_32               ;从硬盘读取文件到内存，上面eax，ebx，ecx是参数</span><br><span class="line">;创建页目录和页表并初始化页内存位图</span><br><span class="line">call setup_page</span><br></pre></td></tr></table></figure>

<p><code>rd_disk_m_32</code>是从硬盘上读取文件的函数，与 mbr 中的<code>rd_disk_m_16</code>函数只是版本由 16 位变成了 32 位的。</p>
<ol start="2">
<li><strong>初始化内核</strong>：需要在分页后，将加载进来的 elf 内核文件安置到相应的虚拟内存地址，然后跳过去执行</li>
</ol>
<p>初始化内核就是根据 elf 规范将内核文件中的段（segment）展开到（复制到）内存中的相应位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">        ;开启分页后，用gdt新的地址重新加载</span><br><span class="line">        lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">        jmp SELECTOR_CODE:enter_kernel  ;强制刷新流水线，更新 gdt</span><br><span class="line"></span><br><span class="line">enter_kernel:</span><br><span class="line">        call kernel_init</span><br><span class="line">        mov esp, 0xc009f000     ;给栈选个高地址且不影响内存其他位置的地方</span><br><span class="line">        jmp KERNEL_ENTRY_POINT</span><br><span class="line">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span><br><span class="line">kernel_init:</span><br><span class="line">        xor eax, eax</span><br><span class="line">        xor ebx, ebx		;ebx记录程序头表地址</span><br><span class="line">        xor ecx, ecx		;cx记录程序头表中的program header数量</span><br><span class="line">        xor edx, edx		;dx 记录program header尺寸,即e_phentsize</span><br><span class="line"></span><br><span class="line">        mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  ; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br><span class="line">        mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span><br><span class="line">					  ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span><br><span class="line">        add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">        mov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="line">.each_segment:</span><br><span class="line">        cmp byte [ebx + 0], PT_NULL		  ; 若p_type等于 PT_NULL,说明此program header未使用。</span><br><span class="line">        je .PTNULL</span><br><span class="line"></span><br><span class="line">        ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br><span class="line">        push dword [ebx + 16]		  ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br><span class="line">        mov eax, [ebx + 4]			  ; 距程序头偏移量为4字节的位置是p_offset</span><br><span class="line">        add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br><span class="line">        push eax				  ; 压入函数memcpy的第二个参数:源地址</span><br><span class="line">        push dword [ebx + 8]			  ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br><span class="line">        call mem_cpy				  ; 调用mem_cpy完成段复制</span><br><span class="line">        add esp,12				  ; 清理栈中压入的三个参数</span><br><span class="line">.PTNULL:</span><br><span class="line">        add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header</span><br><span class="line">        loop .each_segment</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="line">;输入:栈中三个参数(dst,src,size)</span><br><span class="line">;输出:无</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">mem_cpy:</span><br><span class="line">        cld</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        push ecx		   ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br><span class="line">        mov edi, [ebp + 8]	   ; dst</span><br><span class="line">        mov esi, [ebp + 12]	   ; src</span><br><span class="line">        mov ecx, [ebp + 16]	   ; size</span><br><span class="line">        rep movsb		   ; 逐字节拷贝</span><br><span class="line"></span><br><span class="line">        ;恢复环境</span><br><span class="line">        pop ecx</span><br><span class="line">        pop ebp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>函数 <code>kernel_init</code> 的作用是将 kernel.bin 中的段（ segment）拷贝到各段自己被编译的虚拟地址处，将这些段单独提取到内存中，这就是平时所说的内存中的程序映像。kernel init 的原理是分析程序中的每个段(segment)，如果段类型不是 PT<em>NULL(空程序类型），就将该段拷贝到编译的地址中。<br>函数<code>mem_cpy</code>的作用是将 src 指向的地址空间处的连续 n 个字节拷贝到 dest 指向的地址空间，此函数的原型相当于 mem_cpy(void</em> <em>dest,</em> _void* src, int size),所以此处需要提供三个参数，这三个参数都在程序头中，所以他们都可以基于 ebx+偏移量来得到。怎么传递参数呢？在汇编语言中传递参数的方法太多了，可以把参数放入寄存器中，也可以放入栈中，亦或直接放入某块内存中，类似共享内存的方式来传递参数。我们这里把参数放入栈中保存，而且参数的入栈顺序是从右往左。<br>说点题外话：</p>
<h5 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h5><p>栈是从上往下发展的，而且栈底是用不上的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669032934766-36f7ba69-0d59-4a4a-b0e8-bd5d52944fd6.png#averageHue=%23dedede&clientId=uc09812de-f752-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=321&id=uc85cfb37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=667&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=221984&status=done&style=none&taskId=u886bbe5e-9381-41a8-a569-6694a498cdd&title=&width=444.6666666666667" alt="image.png"><br>由于栈指针 esp 已经在 loader 中被加上了<code>0xc0000000</code>，所以栈中地址都是内核所在的高地址。用 call 指令进行函数调用时，CPU 会自动在栈中压入返回地址。</p>
<h5 id="字符串搬运指令族"><a href="#字符串搬运指令族" class="headerlink" title="字符串搬运指令族"></a>字符串搬运指令族</h5><p><code>movsb</code>、<code>movsw</code>、<code>movsd</code>，其中<code>movs</code>代表 move string，后面的 b 代表 byte，w 代表 word，d 代表 dword。所以 movsb 代表复制 1 字节，movsw 代表复制 2 字节，movsd 代表复制 4 字节。<br>这三条指令是将<code>DS : [E]SI</code>指向地址处的相应字节大小搬到<code>ES: [E]DI</code>指向的地址处。16 位环境下用 SI 和 DI 寄存器，32 位环境下用 ESI 和 EDI 寄存器。复制字符串是表象，本质上是复制字节，所以它被用于复制数据。</p>
<h5 id="重复运行指令"><a href="#重复运行指令" class="headerlink" title="重复运行指令"></a>重复运行指令</h5><p><code>rep</code>指令，该指令是按照 ecx 寄存器中指令的次数重复执行后面指定的指令，每执行一次 ecx 自减 1，直到 ecx 等于 0 为止。<br>重复复制数据的话需要有指令来更新数据的来源和目的地，这时<code>cld</code>和<code>std</code>就派上用场了，这两个指令本质上是控制重复执行字符串指令时的 esi 和 edi 的递增方式，递增方式是指他们的地址是往高地址变化还是低地址变化。<br><code>cld</code>是指 clean direction，作用是将 eflags 寄存器中的方向标志位 DF 置为 0，这样 rep 循环执行后面的指令时，esi 和 edi 会根据使用的字符串搬运指令自动加上搬运数据的字节大小，这是由 CPU 自动完成的，不用人工干预。<br><code>std</code>是指 set direction，该指令是将方向标志位置为 1，req 循环执行后 esi 和 edi 会自动减去所搬运数据的大小。<br>字符串操作还有 ins[bwd]、outs[bwd]、lods[bwd]和 stos[bwd]。</p>
<p>进入内核后栈地址改为<code>0xc009f000</code>，目前的内存布局如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669203325203-69066bb0-6ea3-44fe-8ece-ed6031575747.png#averageHue=%23e8e8e8&clientId=u7d4fa026-1815-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=329&id=u31e462da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=346&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=94509&status=done&style=none&taskId=ua8abad22-8db8-482f-9e42-c445acecdf0&title=&width=230.66666666666666" alt="image.png"></p>
<h2 id="5-4-特权级深入浅出"><a href="#5-4-特权级深入浅出" class="headerlink" title="5.4 特权级深入浅出"></a>5.4 特权级深入浅出</h2><blockquote>
<p>所谓保护模式下的“保护”，主要体现在特权级上，以后随着后面工作的展开，会越来越多地和它们打交道。</p>
</blockquote>
<h4 id="5-4-1-特权级那点事"><a href="#5-4-1-特权级那点事" class="headerlink" title="5.4.1 特权级那点事"></a>5.4.1 特权级那点事</h4><p>整个计算机世界可以分为两部分，访问者和受访者。访问者的特权级是可以改变的，受访者的特权不能变。<br>程序特权级按照权力从大到小分为 0、1、2、3 级，数字越小，权力越大。0 级特权是操作系统内核所在的特权级，计算机在启动之初就以 0 级特权运行，例如 MBR 就是以 0 级特权运行的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669204224312-2b8c7dda-552f-41b8-ae81-25b352a9d69f.png#averageHue=%23eaeaea&clientId=u7d4fa026-1815-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u6d907c3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=433&originWidth=569&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=131796&status=done&style=none&taskId=u1b36beca-1a90-43f4-bdd8-b22f6358cba&title=&width=379.3333333333333" alt="image.png"></p>
<ul>
<li>操作系统位于最内环的 0 级特权，它要直接控制硬件，掌控各种核心数据，所以它的权利必须最大。</li>
<li>系统程序分别位于 1 级特权和 2 级特权，运行在这两层的程序一般是虚拟机、驱动程序等系统服务。</li>
<li>在最外层的是 3 级特权，用户程序就运行在此层。</li>
</ul>
<h4 id="5-4-2-TSS-简介（了解）"><a href="#5-4-2-TSS-简介（了解）" class="headerlink" title="5.4.2 TSS 简介（了解）"></a>5.4.2 TSS 简介（了解）</h4><p>TSS，即 Task State Segment，意为任务状态段， 它是处理器在硬件上原生支持多任务的一种实现方式，也就是说处理器原本是想让操作系统开发厂商利用此结构实现多任务的，人家处理器厂商已经提供了多任务管理的解决方案，只是后来操作系统不买账。TSS 是一种数据结构，它用于存储任务的环境。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1669724582215-be4bd5f6-30e9-4d9c-8fc3-4cd42806d97e.png#averageHue=%23d5d5d5&clientId=u14d6c426-0610-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=753&id=ud5c10b91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1129&originWidth=724&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=454423&status=done&style=none&taskId=u71c68ab3-0459-4686-b9ed-34ed3756e11&title=&width=482.6666666666667" alt="image.png"><br>TSS 是每个任务都有的结构， 它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段。该结构看上去也有点复杂，里面众多寄存器都囊括到这 104 字节中啦，其实这 104 字节只是 TSS 的最小尺寸，根据需要，还可以再接上个 IO 位图，这些内容将在后面章节用到时补充。这里目前只需要关注 28 字节之下的部分，这里包括了 3 个栈指针。<br>在没有操作系统的情况下，可以认为进程就是任务，任务就是一段在处理器上运行的程序，相当于某个计算机高手在脱离操作系统的情况下所写的代码，它能让计算机很好地运行。在有了操作系统之后，程序可分为用户程序和操作系统内核程序，故之前完整的一个任务也因此被分为用户部分和内核部分。由于内核程序位于 0 特权级，用户程序位于 3 特权级，所以， 一个任务按特权级来划分的话，实质上是被分成了 3 特权级的用户程序和 0 特权级的内核程序，这两部分加在一起才是能让处理器完整运行的程序，也就是说完整的任务要历经这两种特权的变换。所以我们平时在 Linux 下所写的程序只是个半成品，咱们只负责完成用户态下的部分，内核态的部分由操作系统提供。<br>任务是由处理器执行的，任务在特权级变换时，本质上是处理器的当前特权级在变换，由一个特权级变成了另外一个特权级。这就开始涉及栈的问题了，处理器固定，处理器在不同特权级下，应该用不同特权级的栈，原因是如果在同一个栈中容纳所有特权级的数据时，这种交叉引用会使栈变得非常混乱，并且用一个栈容纳多个特权级下的数据，栈容量有限很容易溢出。<br>每个任务的每个特权级下只能有一个栈，不存在一个任务的某个特权级下存在多个同特权级栈的情况。也就是说， 一共 4 个特权级， 一个任务“最多”有 4 个栈。既然一个 TSS 代表一个任务，每个任务 又有 4 个栈，那为什么 TSS 中只有 3 个栈： ss0 和 esp0、ss1 和 esp1、ss2 和 esp2？它们分别代表 0 级栈的段选择子和偏移量、1 级栈的段选择子和偏移量、2 级栈的段选择子和偏移量。<br>前面说的一个任务最多拥有 4 个栈，并不是所有的任务都是这样的。特权级在变换时，需要用到不同特权级下的栈，当处理器进入不同的特权级时，它自动在 TSS 中找同特权级的栈。由于 TSS 是处理器硬件原生的系统级数据结构，处理器知道 TSS 中哪些字段是目标栈的选择子及偏移量。</p>
<h5 id="特权级转移"><a href="#特权级转移" class="headerlink" title="特权级转移"></a><strong>特权级转移</strong></h5><p>特权级转移分为两类， 一类是由中断门、调用门等手段实现低特权级转向高特权级，另一类则相反，是由调用返回指令从高特权级返回到低特权级，这是唯一一种能让处理器降低特权级的情况。<br>对于第 1 种一一特权级由低到高的情况，由于不知道目标特权级对应的栈地址在哪里，所以要提前把目标栈的地址记录在某个地方，当处理器向高特权级转移时再从中取出来加载到 SS 和 ESP 中以更新栈， 这个保存的地方就是 TSS。处理器会自动地从 TSS 中找到对应的高特权级栈地址，这一点对开发人员是透明的，咱们只需要在 TSS 中记录好高特权级的栈地址便可。<br>也就是说，除了调用返回外，处理器只能由低特权级向高特权级转移， TSS 中所记录的栈是转移后的高特权级目标栈，所以它一定比当前使用的栈特权级要高，只用于向更高特权级转移时提供相应特权的栈地址。 进一步说， TSS 中不需要记录 3 特权级的栈，因为 3 特权级是最低的，没有更低的特权级会向它转移。</p>
<blockquote>
<p>不是每个任务都有 4 个栈， 一个任务可有拥有的栈的数量取决于当前特权级是否还有进一步提高的可能，即取决于它最低的特权级别。比如 3 特权级的程序，它是最低的特权级，还能提升三级，所以可额外拥有 2、1、0 特权级栈，用于将特权分别转移到 2、1 、0 级时使用。 2 特权级的程序，它还可以提升两级，所以可额外拥有 1、0 特权级栈，用于将特权级分别转移到 1、0 级时使用。以此类推， 1 特权级的程序， 它可以额外拥有 0 特权级栈。特权级已经是至高无上了，只有这一个 0 级栈。</p>
</blockquote>
<p>对于第 2 种一一由高特权返回到低特权级的情况，处理器是不需要在 TSS 中去寻找低特权级目标栈的。正常情况下，特权级由低向高转移在先，由高向低返回在后，即只有先向更高特权级转移，才能谈得上再从高特权级回到低特权级。当处理器由低向高特权级转移时，它自动地把当时低特权级的栈地址（SS 和 ESP）压入了转移后的高特权级所在的栈中，所以当用返回指令如 retf 或 iret 从高特权级向低特权级返回时，处理器可以用当前使用的搞特权级的栈中获取低特权级的栈段选择子及偏移量。由高特权级返回低特权级的过程称为“向外层转移”。</p>
<h5 id="处理器如何找到-TSS"><a href="#处理器如何找到-TSS" class="headerlink" title="处理器如何找到 TSS"></a>处理器如何找到 TSS</h5><p>TSS 是硬件支持的系统数据结构，它和 GDT 等一样，由软件填写其内容，由硬件使用。 GDT 也要加载到寄存器 GDTR 中才能被处理器找到， TSS 也是一样，它是由 TR ( Task Register）寄存器加载的，每次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS。<br>正是由于处理器提供了硬件方面的框架，所以很多工作都是“自动”完成的，虽然操作系统看上去是底层的技术，但其实也属于“应用型”开发。</p>
<h4 id="5-4-3-CPL-和-DPL-入门"><a href="#5-4-3-CPL-和-DPL-入门" class="headerlink" title="5.4.3 CPL 和 DPL 入门"></a>5.4.3 CPL 和 DPL 入门</h4><blockquote>
<p>计算机特权级的标签体现在 DPL 、 CPL 和 RPL。</p>
</blockquote>
<p>指令“请求”、“访问”其他资源的能力等级便称之为请求特权级，指令存放在代码段中，所以，就用代码段寄存器 CS 中选择子的 RPL 位表示代码请求别人资源能力的等级。代码段寄存器 CS 和指令指针寄存器 EIP 中指向的指令便是当前在处理器中正在运行的代码，所以位于 CS 寄存器中选择子低 2 位的值不仅称为请求特权级，又称为处理器的当前特权级，也就是说<strong>处理器的当前特权级是 CS.RPL</strong>。<br>在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是代码段描述符中的 DPL，便是当前 CPU 所处的特权级，这个特权级称为当前特权级，即 CPL( Current Privilege Level），它表示处理器正在执行的代码的特权级别。<br>指令最终是用处理器执行的，执行到不同特权的代码，处理器的特权级就换到不同的等级。所以，当前特权级实际上是指处理器当前所处的特权级，是指处理器的特权角色，更形象一点地说，是指 CPU 当前在计算机世界中的特权地位。<br>当前正在运行的代码所在的代码段的特权级 DPL 就是处理器的当前特权级。当处理器从一个特权级的代码段转移到另一个特权级的代码段上执行时，由于两个代码段的特权级不一样，处理器当前的特权身份起了变化，这就是当前特权级 CPL 改变的原因。其实就是使用了那些能够改变程序执行流的指令，如 int、call 等，这样就使 CS 和 EIP 的值改变，从而使处理器执行到了不同特权级的代码。</p>
<h5 id="受访者的特权标签"><a href="#受访者的特权标签" class="headerlink" title="受访者的特权标签"></a>受访者的特权标签</h5><p>在段描述符中有一个属性还为该内存标明了特权等级，这就是段描述符中的 DPL 字段的作用，它就是受访者的特权标签。不仅段描述符中有 DPL 字段，以后所介绍的所有描述符都有 DPL。DPL，即 Descriptor Privilege Level，描述符特权级。</p>
<ul>
<li>对于受访者为<strong>数据段</strong>(段描述符中 type 字段中没有 X 可执行属性)来说：只有访问者权限<strong>大于等于</strong>该 DPL 表示的最低权限才能够继续访问</li>
<li>对于受访者为<strong>代码段</strong>(段描述符中 type 字段中有 X 可执行属性)来说：只有访问者权限<strong>等于</strong>该 DPL 表示的最低权限才能够继续访问，即只能平级访问。任何权限大于或小于它的访问者都将被 CPU 拒之门外。</li>
</ul>
<p>唯一一种处理器会从高特权降到低特权运行的情况：处理器从中断处理程序中返回到用户态的时候。在中断的处理过程中需要具备访问硬件的能力，在大多数情况下只 有 CPU 处于 O 特权级才能访问硬件，这是因为 eflags 寄存器中的 IOPL 位的值通常被设置为 0，并且 TSS 中不存在 IO 位图。而且有些中断处理中需要的指令只能在 0 特权级下使用，这部分指令称为特权指令，所以中断发生后其处理的过程必须在 0 特权级下进行。</p>
<h5 id="不提升特权级执行执行高特权级代码段指令"><a href="#不提升特权级执行执行高特权级代码段指令" class="headerlink" title="不提升特权级执行执行高特权级代码段指令"></a>不提升特权级执行执行高特权级代码段指令</h5><p>使用一致性代码段。在段描述符中如果该段为非系统段（段描述符的 S 字段为 0），可以用 type 字段中的 C 位来表示该段是否为一致性代码段。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段。一致性代码段是指若自己是转移后的代码单，自己的特权级 DPL 一定要大于等于转移前的 CPL，而且转移后 CPL 不会用该目标段的 DPL 替换，即转移后 CPL 不变。</p>
<blockquote>
<p>代码段有一致性和非一致性之分，但所有的数据段都是非一致的。</p>
</blockquote>
<h4 id="5-4-4-门、调用门与-RPL-序"><a href="#5-4-4-门、调用门与-RPL-序" class="headerlink" title="5.4.4 门、调用门与 RPL 序"></a>5.4.4 门、调用门与 RPL 序</h4><p>处理器只有通过“门结构”才能由低特权级转移到高特权级。而门结构就是记录一段程序起始地址的描述符。门描述符用来描述一段程序。进入门处理器就能转移到更高的特权级上。门描述符同段描述符类似，都是 8 字节大小的数据结构，用来描述门中通向的代码。<br>一共有四种门结构：</p>
<ol>
<li>任务门：任务以任务状态段 TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时， 如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用 call 或 jmp 指令后接任务门的选择子或任务 TSS 的选择子。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670320163960-5a71866f-f253-48bd-8799-0a3fc0bc63a3.png#averageHue=%23efefef&clientId=udd6df763-df54-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u77424c05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=403&originWidth=1169&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=145285&status=done&style=none&taskId=ud7b9924e-5dd8-4d27-af39-2a047feb577&title=&width=779.3333333333334" alt="image.png"></p>
<ol start="2">
<li>中断门：以 int 指令主动发中断的形式实现从低特权向高特权转移；</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670320177468-2a9dc1a7-c9ef-4b20-93f0-068b998e7702.png#averageHue=%23dcdcdc&clientId=udd6df763-df54-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=ub4fbc8eb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=1191&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=273831&status=done&style=none&taskId=u289c82eb-4c8b-489a-839e-8422fdfc555&title=&width=794" alt="image.png"></p>
<ol start="3">
<li>陷阱门：以 int3 指令主动发中断的形式实现从低特权向高特权转移，一般是编译器在调试时用；</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670320268433-41e10b6a-b472-41fb-9e6b-fd78d8aeec87.png#averageHue=%23dedede&clientId=udd6df763-df54-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=281&id=u5f0b1360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=1195&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=290150&status=done&style=none&taskId=u5699bf2d-7d3f-4abd-a08a-b68b5f84436&title=&width=796.6666666666666" alt="image.png"></p>
<ol start="4">
<li>调用门：call 和 jmp 指令后接调用门选择子为参数，以调用函数例程的形式实现从低特权向高特权转移，可用来实现系统调用。 call 指令使用调用门可以实现向高特权代码转移， jmp 指令使用调用门只能实现向平级代码转移。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670320278849-c7c93dea-9d72-46da-9ddf-6a866e231eaa.png#averageHue=%23dddddd&clientId=udd6df763-df54-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ucd99034c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=1193&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=271937&status=done&style=none&taskId=u000653aa-2052-4702-ae28-ac98359aea1&title=&width=795.3333333333334" alt="image.png"><br>任务门是用任务 TSS 的描述符选择子来描述一个任务，除了任务门外，其他三种门都是对应到一段例程，即对应一段函数，故需要用“代码段选择子+段内偏移量”来确定程序的确切地址。无论是哪种门描述符，他们中所记录的信息都已经可以确定所描述的对象（例程或任务）了，所以在被调用时，CPU 都会忽略<strong>指令</strong>中的偏移量。</p>
<ul>
<li>任务门描述符位于 GDT、 LDT 或 IDT（中断描述符表）中</li>
<li>调用门位于 GDT 或 LDT 中</li>
<li>中断门和陷阱门仅位于 IDT 中</li>
</ul>
<p>任务门、调用门都可以用 call 和 jmp 指令直接调用，原因是这两个门描述符都位于 GDT 或 LDT，访问它们同普通的段描述符是一样的，必须通过选择子，因此只要在 call 或 jmp 指令后接任务门或调用门的选择子便可调用它们。而陷阱门和中断门只存在于 IDT 中，因此不能主动调用，只能由中断信号来触发调用。</p>
<blockquote>
<p>现代操作系统很少用到调用门和任务门，在咱们的系统中也只用到了中断门，而陆阱门是供调试器用的，咱们并未打算支持应用程序的调试，一方面工作量较大，另一方面违背咱们的初衷，就是想通过更少的代码了解操作系统原理。</p>
</blockquote>
<p>门描述符的 DPL 要低于等于 CPL，否则访问者连门都进不去，门中包含的目标程序所在的段的 DPL 要高于或等于 CPL，不然还使用门干嘛。<br>操作系统可以利用调用门实现一些系统功能（但现代操作系统用调用门实现系统调用并不是主流， 一 般是用中断门实现系统调用），用户程序需要系统服务时可以调用该调用门以获得内核帮助。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670327860814-fd0523e1-bdf2-4075-adc2-29858e41790e.png#averageHue=%23eaeaea&clientId=udd6df763-df54-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=403&id=u7ada3c2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=604&originWidth=859&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=223665&status=done&style=none&taskId=u08c33fd8-e430-4303-a547-57b89497d3e&title=&width=572.6666666666666" alt="image.png"><br>不同特权级下处理器用不同的栈，处理器处于 3 特权级下时要用 3 特权级下的栈，处理器处于 0 特权级下要用 0 特权级下的栈。所以用户传入参数是在 3 特权级下做的，但内核服务程序是在 0 特权级下，他需要在 0 特权级栈中获取参数。处理器的设计者也看到了这一点，故为了方便软件开发人员，处理器在固件上实现参数的自动复制，即，将用户进程压在 3 特权级栈中的参数自动复制到 0 特权级栈中。所以在调用门描述符中的高 32 位有个“参数个数”，这是专门给处理器准备的。</p>
<h4 id="5-4-5-调用门的过程保护"><a href="#5-4-5-调用门的过程保护" class="headerlink" title="5.4.5 调用门的过程保护"></a>5.4.5 调用门的过程保护</h4><p>通过调用门也不能由高特权级转向低特权级，只有通过返回指令如 retf 或 iret 才能够做到由高特权级转移到低特权级。</p>
<h5 id="通过-call-指令调用“调用门”的过程："><a href="#通过-call-指令调用“调用门”的过程：" class="headerlink" title="通过 call 指令调用“调用门”的过程："></a>通过 call 指令调用“调用门”的过程：</h5><blockquote>
<p>假设在 32 位模式下用户进程要调用某个调用门，该门描述符中参数的个数是 2，调用前的当前特权级是 3，调用后的新特权级为 0。</p>
</blockquote>
<ol>
<li>为调用门提供 2 个参数。向当前特权级栈，即 3 特权级栈压入两个参数。</li>
<li>确定新特权级栈的栈。根据门描述符中选择子对应的目标代码段的 DPL，这里 DPL 为 0，处理器自动在 TSS 中找到合适的栈段选择子 SS 和栈指针 ESP，为了方便叙述，这里记作 SS_new 和 ESP_new。</li>
<li>检查新栈段选择子对应的描述符的 DPL 和 TYPE，如果未通过检查则处理器引发异常。</li>
<li>特权级栈转换。这里将旧栈段记为 SS_old 和 ESP_old，处理器先找个地方临时保存 SS_old 和 ESP_old，之后将 SS_new 加载到栈段寄存器 SS，将 ESP_new 加载到栈指针寄存器 esp，这样便启动了新栈。</li>
<li>将 SS_old 和 ESP_old 压入当前新栈中（即 0 特权级栈中），由于栈操作数是 32 位，SS_old 是 16 位数据，故将其高 16 位用 0 填充后入栈保存。如图 5-56A。</li>
<li>复制 3 特权级栈的参数到 0 特权级栈。如图 5-56B。</li>
<li>备份 CS 和 EIP 寄存器。由于调用门描述符中记录的是目标程序所在代码段的选择子及偏移地址，这都意味着代码段寄存器 CS 要用该选择子重新加载，只要段寄存器被加载，段描述符缓冲寄存器就会被刷新，所以需要将当前代码段 CS 和 EIP 都备份在栈中，这两个值记为 CS_old 和 EIP_old，由于 CS_old 是 16 位数据故高位补 0 后再入栈。如图 5-56C。</li>
<li>运行调用门指向的程序。将门描述符中国你的代码段选择子和偏移量分别装载到 CS 和 EIP 寄存器中。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670400363542-250838b1-ff53-4a2b-928f-c719c6b90222.png#averageHue=%23ededed&clientId=u66689bbd-e19b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u26ba7472&margin=%5Bobject%20Object%5D&name=image.png&originHeight=407&originWidth=1238&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=184357&status=done&style=none&taskId=u3254068e-c44c-498f-b97f-545fdb9bc74&title=&width=825.3333333333334" alt="image.png"></p>
<blockquote>
<p>若在第 2 步处理器发现是平级转移，处理器并不会更新当前栈，也就是说不会从 TSS 中在此选择同级的栈载入 SS 和 ESP，处理器只是把此转移当成直接远转移，直接跳到第 7 步。</p>
</blockquote>
<p>用 retf 指令将返回地址从栈中弹出到 CS 和 EIP，将低特权级地址弹出到 SS 和 ESP。</p>
<h5 id="用-retf-指令从调用门返回的过程："><a href="#用-retf-指令从调用门返回的过程：" class="headerlink" title="用 retf 指令从调用门返回的过程："></a>用 retf 指令从调用门返回的过程：</h5><ol>
<li>特权级检查。检查栈中 CS 选择子，根据其 RPL 位判断返回过程中是否要改变特权级。</li>
<li>获取栈中 CS_old 和 EIP_old，根据 CS_old 选择子对应的代码段的 DPL 及选择子中的 RPL 做特权级检查。检查通过将 EIP_old 和 CS_old 处理后弹出到 EIP 和 CS 寄存器。</li>
<li>跳过<code>参数个数*参数大小</code>。此时栈指针 ESP_new 指向 ESP_old。</li>
<li>若第 1 步中判断出需改变优先级，则栈中弹出 SS_old 和 ESP_old 处理后存到 SS 和 ESP 寄存器中。<blockquote>
<p>注意：处理器执行 retf 指令从内核态返回时，处理器顶多是把栈中低特权级的 CS、EIP、SS 以及 ESP 的值重新加载到寄存器中，像 DS 等数据段寄存器是不会被更新的。若某个寄存器中选择子指向的数据段描述符的 DPL 比返回后的 CPL 高，但用户进程依然可以直接访问该数据段数据，这就出问题了。<br>一个可行解决办法是操作系统代码在使用任何一个数据段寄存器时，先将其入栈，然后再更新选择子，在使用完毕后，操作系统再将压入栈的选择子出栈回复到该段寄存器。但这只是用软件来避免此问题的办法，处理器不相信第三方的软件都会处理好此问题，故当出现这种情况时，处理器会把 0 填充到相应的段寄存器，从而让处理器引发异常（访问 0 号段描述符异常）。</p>
</blockquote>
</li>
</ol>
<h4 id="5-4-6-RPL-的前世今生"><a href="#5-4-6-RPL-的前世今生" class="headerlink" title="5.4.6 RPL 的前世今生"></a>5.4.6 RPL 的前世今生</h4><p>目前资源访问的两个必须保证的客观条件：</p>
<ol>
<li>用户不能访问系统资源</li>
<li>处理器必须陷入内核才能帮助用户程序做事</li>
</ol>
<p>在只有 CPL 和 DPL 情况下，用户程序可以借助内核程序来获得内核数据，这是万万不可的。故此时引入 RPL，用 RPL 代表真正资源需求者的 CPL，以后在请求某特权级为 DPL 的资源时，要求 CPL 和 RPL 的特权级都大于等于 DPL，即数值上 CPL≤DPL 且 RPL≤DPL。<br>修改 RPL 可以使用<code>arpl</code>指令。</p>
<h4 id="5-4-7-IO-特权级"><a href="#5-4-7-IO-特权级" class="headerlink" title="5.4.7 IO 特权级"></a>5.4.7 IO 特权级</h4><p>eflags 寄存器中第 12 ～ 13 位是 IOPL CI&#x2F;O Privilege Level)，即 IO 特权级，它除了限制当前任务进行 IO 敏感指令的最低特权级外，还用来决定任务是否允许操作全部 IO 端口，这里是全部 IO 端口， IOPL 位是打开所有 IO 端口的开关（用来单独设置端口访问的方式是 IO 位图）。每个任务（内核进程或用户进程）都有自己的 eflags 寄存器，所以每个任务都有自己的 IOPL，它表示当前任务要想执行所有 IO 指令的最低特权级。<br>可以用 popf 和 iretd 指令改变 IOPL 。<br>即使特权级数值上 CPL &gt; IOPL，还可以通过 IO 位图来设置部分端口的访问权限，处理器这么做是为了提速。</p>
<blockquote>
<p>如果所有 IO 端口访问都要经过内核的话，由低特权级转向高特权级时是需要保存任务上下文环境的，这个过程也是要消耗处理器时间的，随着端口访问变多，时间成本也会变多。典型应用就是硬件的<strong>驱动程序</strong>，它位于特权级 1.<br>驱动程序是通过 in、out 等 IO 指令直接访问硬件的程序，它为上层程序提供对硬件的控制访问，相当于硬件的代理。</p>
</blockquote>
<p>Intel 处理器最大支持 65536 个端口，它允许任务通过 I&#x2F;O 位图来开启特定端口，65536 个端口号占用的位图大小是 65536&#x2F;8 &#x3D; 8192 字节，即 8KB。若 I&#x2F;O 位图中相应 bit 被置为 0，表示可以访问，否则为 1 时则禁止访问。<br>注意，I&#x2F;O 位图只在 CPL &gt; IOPL 时有效， CPL ≤ IOPL 时任何接口都可直接访问。<br>I&#x2F;O 位图是位于 TSS 中的，若 TSS 中没有 I&#x2F;O 位图便默认为禁止访问所有端口。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1249968/1670759203562-02cf63bb-703c-4fdf-b931-8054eb577e44.png#averageHue=%23e6e6e6&clientId=u25d7f942-0bdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=298&id=ue528c4ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=447&originWidth=648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=161196&status=done&style=none&taskId=u130890a2-c8b1-4e5f-a391-c6a78c5db77&title=&width=432" alt="image.png"><br>若 TSS 中有 I&#x2F;O 位图，其大小为“I&#x2F;O 位图偏移地址”+ 8192 + 1 字节，其中 1 字节是 I&#x2F;O 位图中最后的 0xff。<br>若没有 I&#x2F;O 位图，TSS 最小尺寸为 104 字节。</p>
<h5 id="I-x2F-O-位图最后一个字节为-0xff-的原因"><a href="#I-x2F-O-位图最后一个字节为-0xff-的原因" class="headerlink" title="I&#x2F;O 位图最后一个字节为 0xff 的原因"></a>I&#x2F;O 位图最后一个字节为 0xff 的原因</h5><p>计算机系统硬件中，IO 端口是按字节编址的，意思是一个端口只能读写 1 个字节的数据，如果对一个端口连续读写多个字节，实际上是从以改端口号为起始的多个端口一起读进来的。</p>
<blockquote>
<p>例如： in 指令可以读取 16 位端口数据，即一次读取 2 字节，假设端口 0x234 为 16 位端口：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in ax, 0x234</span><br><span class="line"># 相当于</span><br><span class="line">in al, 0x234</span><br><span class="line">in ah, 0x235</span><br></pre></td></tr></table></figure>

<p>连续的多个 bit 也许会跨字节，这样处理器必须将这两个字节都读进来处理。但当第 1 个 bit 为在位图的最后一个字节就会出问题，处理器要读进 2 个字节，但在第 2 个字节时越界了，该字节不属于位图范围。因此位图最后 1 字节设置为 0xFF，可以有两个作用：</p>
<ol>
<li>字节为 1 表示禁止访问此字节表示的端口，还能禁止访问位图范围外的端口；</li>
<li>用作位图的边界标记。</li>
</ol>
	
		</div>
		
		<div id="current-post-cover" data-scr="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/01/20/yuque/dch1fprebtaxtqq8/" title="《操作系统真象还原》：第八章 内存管理系统">
								《操作系统真象还原》：第八章 内存管理系统			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 20日, 2023				
							</p>
							<p class="relate-post-content">
								8.1 makefile 简介
这部分可参考阮一峰的讲解：https://www.ruanyifeng.com/blog/2015/02/make.html

8.1.1 makefile 是什么makefile 是 Linux 下编...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/01/20/yuque/dch1fprebtaxtqq8/" title="《操作系统真象还原》：第八章 内存管理系统">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第八章 内存管理系统"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">
								《操作系统真象还原》：第七章 中断			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 25日, 2022				
							</p>
							<p class="relate-post-content">
								7.1 中断是什么，为什么要有中断运用中断能够显著提升并发，从而大幅提升效率。
7.2 操作系统是中断驱动的略
7.3 中断分类把中断按事件来源分类，来自 CPU 外部的中断就称为外部中断，来自 CPU 内部的中断称为内部中断。外部中...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/25/yuque/gf0t07d01kr4oe9r/" title="《操作系统真象还原》：第七章 中断">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第七章 中断"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">
								《操作系统真象还原》：第六章 完善内核			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 18日, 2022				
							</p>
							<p class="relate-post-content">
								6.1 函数调用约定简介咱们实验使用cdecl。这里提一下stdcall，cdecl与stdcall的区别在于由谁来回收栈空间。stdcall是被调用者清理参数所占的栈空间。举例来说：
12int subtract(int a, in...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/12/18/yuque/yh5mcml2bb6o3kpg/" title="《操作系统真象还原》：第六章 完善内核">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第六章 完善内核"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">
								《操作系统真象还原》：第五章 保护模式进阶——内存分页机制			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 19日, 2022				
							</p>
							<p class="relate-post-content">
								
从这一刻起，我们才算开始了真正的操作系统学习之旅

5.1 获取物理内存容量5.1.1 Linux 获取内存的方法在 Linux 2.6 内核总是用detect_memory函数来获取内存容量的。其函数子啊本质上是通过调用 BIOS...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/19/yuque/eg33ul1eh4zf6lzi/" title="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第五章 保护模式进阶——内存分页机制"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">
								《操作系统真象还原》：第四章 保护模式入门			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 8日, 2022				
							</p>
							<p class="relate-post-content">
								4.1 保护模式概述在本章大家会见到全局描述符表、中断描述符表、各种门结构，这是 CPU 提供给应用的，咱们用好就行。保护模式强调的是“保护”，它是在 Intel 80286 CPU 中首次出现，这是继 8086 之后，Intel 紧...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/11/08/yuque/qmb3g6pmmzfkbxg5/" title="《操作系统真象还原》：第四章 保护模式入门">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第四章 保护模式入门"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">
								《操作系统真象还原》：第三章 完善MBR——I/O接口			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 25日, 2022				
							</p>
							<p class="relate-post-content">
								3.3 让我们对显示器说点什么吧3.3.1 CPU 如何与外设通信——IO 接口IO 接口功能：

设置数据缓冲，解决 CPU 与外设的速度不匹配
设置信号电平转换电路
设置数据格式转换
设置时序控制电路来同步 CPU 和外部设备
提...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/25/yuque/fvxk1z/" title="《操作系统真象还原》：第三章 完善MBR——I/O接口">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第三章 完善MBR——I/O接口"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/11/yuque/xa16pm/" title="《操作系统真象还原》：第三章 完善MBR——CPU的实模式">
								《操作系统真象还原》：第三章 完善MBR——CPU的实模式			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 11日, 2022				
							</p>
							<p class="relate-post-content">
								针对汇编几个知识点：

第 1 行和第 4 行的 mov 操作，机器码第 1 个宇节都是B8，而另外第 2、3 行同样是 mov 指令，机器码却有天壤之别，似乎找不到共性。原因是机器码是由很多部分组成的，比如指令前缀、主操作码字节以及...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/11/yuque/xa16pm/" title="《操作系统真象还原》：第三章 完善MBR——CPU的实模式">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第三章 完善MBR——CPU的实模式"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/05/23/yuque/bfwmot/" title="《操作系统真象还原》：第二章 编写 MBR">
								《操作系统真象还原》：第二章 编写 MBR			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 23日, 2022				
							</p>
							<p class="relate-post-content">
								先了解 CPU 的两种工作模式：实模式和保护模式实模式（英语：Real mode）是 Intel 80286 和之后的 x86 兼容 CPU 的操作模式。实模式的特性是一个 20 比特的区段存储器地址空间（意思为只有 1MB 的存储器...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/05/23/yuque/bfwmot/" title="《操作系统真象还原》：第二章 编写 MBR">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第二章 编写 MBR"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/05/09/yuque/wx4152/" title="《操作系统真象还原》：第一章 环境配置">
								《操作系统真象还原》：第一章 环境配置			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 9日, 2022				
							</p>
							<p class="relate-post-content">
								第 0 章：一些你可能正感到迷惑的问题
摘记

0.28 MBR、EBR、DBR 和 OBR 各是什么MBR 位于整个硬盘最开始的块， EBR 位于每个子扩展分区，各子扩展分区中只有一个逻辑分区。 MBR 和 EBR 位于分区之外的扇...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/05/09/yuque/wx4152/" title="《操作系统真象还原》：第一章 环境配置">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="《操作系统真象还原》：第一章 环境配置"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/06/16/yuque/dlziqz/" title="6月阅读总结">
								6月阅读总结			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 16日, 2022				
							</p>
							<p class="relate-post-content">
								
“零拷贝”技术
Sogou C++ Workflow：搜狗公司的 C++服务器引擎，支持 500k QPS
Reducing CPU scheduler latency in Linux：CPU 调度算法 BMQ 和 CFS 的对比...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/06/16/yuque/dlziqz/" title="6月阅读总结">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="https://cdn.jsdelivr.net/gh/lisongqian/lisongqian.github.io@master/img/cart_cover.jpg" alt="6月阅读总结"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	

		

			<!-- gitalk comment -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">

	(function gitalkComment(){
		//Thanks O-R
		//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
		//去除尾部匹配正则数组的字符串  
		//Remove redundant characters
		String.prototype.trimEnd = function(regStr) {
			let result = this;
			if(regStr == undefined || regStr == null || regStr == "") {
				return result;
			}
			let array = regStr.split(',');

			if(array.length > 0) {

				let c = array.shift(), 
					str = this,
					i = str.length,
					rg = new RegExp(c),
					matchArr = str.match(rg);

				if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
					let matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
						.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
						.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
						.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
						.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
						.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
						.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
						.replace(/\./g, "\\.").replace(/\&/g, "\\&");
					matchStr = matchStr + '$';
					result = str.replace(new RegExp(matchStr), "");
				}

				if(array.length > 0) {
					return result.trimEnd(array.join())
				} else {
					return result;
				}
			}
		};

		//Create gitalk
		let gitalk = new Gitalk({
			clientID: '693063c1941dbc1701d3',
			clientSecret: 'f88ddf502ef33ce91ce9d8c140dbc7e3a0653b7e',
			//id: window.location.pathname,
			//id: decodeURI(window.location.pathname),
			//id: (window.location.pathname).split("/").pop().substring(0, 49),
			id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
			repo: 'lisongqian.github.io',
			owner: 'lisongqian',
			admin: 'lisongqian',
			distractionFreeMode: 'false',
		})
		gitalk.render('gitalk-container');		
	})();
</script>

		
		
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>

	<div class="copyright">
		<p>
		<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">鲁ICP备16042410号</a>
			 
				&copy;2017 - 2023, content by SongqianLi. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		

<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>




<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


  
<script src="/plugin/leancloud/av-min.js"></script>
<script src="/js/leancloud-count.js"></script>


	

  

	<!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup scrollbar" >
	<div class="local-search-container">
		<span class="popup-btn-close">
      		ESC
   		</span>
		<div class="local-search-header">
			<div class="input-prompt">				
			</div>
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			<div class="topN-post">				
				

   
	<div id="topN">
		<div class="topN-title" data-title= "热门文章"></div> 
	</div>
	
    <script>
        var limitCount = 10;
        if( $('#topN').length ){
            setTimeout(function() {
                topNPost(limitCount);
			}, 3000);
        }
    </script>
   
								
			</div>
		</div>
	</div>
</div>


<script src="/plugin/search/ziploader.js"></script>
<script src="/js/search.js"></script>


<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>